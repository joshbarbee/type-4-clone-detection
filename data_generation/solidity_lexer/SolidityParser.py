# Generated from SolidityParser.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,177,1234,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,
        5,0,200,8,0,10,0,12,0,203,9,0,1,0,1,0,1,1,1,1,4,1,209,8,1,11,1,12,
        1,210,1,1,1,1,1,2,1,2,1,2,1,2,3,2,219,8,2,1,2,1,2,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,3,2,231,8,2,1,2,1,2,1,3,1,3,1,3,3,3,238,8,3,1,
        4,1,4,1,5,1,5,1,5,1,5,5,5,246,8,5,10,5,12,5,249,9,5,1,5,1,5,1,6,
        3,6,254,8,6,1,6,1,6,1,6,3,6,259,8,6,1,6,1,6,5,6,263,8,6,10,6,12,
        6,266,9,6,1,6,1,6,1,7,1,7,1,7,3,7,273,8,7,1,7,1,7,5,7,277,8,7,10,
        7,12,7,280,9,7,1,7,1,7,1,8,1,8,1,8,1,8,5,8,288,8,8,10,8,12,8,291,
        9,8,1,8,1,8,1,9,1,9,1,9,1,9,5,9,299,8,9,10,9,12,9,302,9,9,1,10,1,
        10,3,10,306,8,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,
        11,1,11,1,11,3,11,320,8,11,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,
        13,5,13,330,8,13,10,13,12,13,333,9,13,3,13,335,8,13,1,13,1,13,1,
        13,1,13,5,13,341,8,13,10,13,12,13,344,9,13,3,13,346,8,13,1,13,3,
        13,349,8,13,1,13,1,13,1,14,1,14,1,14,5,14,356,8,14,10,14,12,14,359,
        9,14,1,15,1,15,3,15,363,8,15,1,16,1,16,1,17,1,17,1,17,5,17,370,8,
        17,10,17,12,17,373,9,17,1,18,1,18,3,18,377,8,18,1,18,3,18,380,8,
        18,1,19,1,19,1,19,3,19,385,8,19,1,19,1,19,1,19,1,19,1,19,5,19,392,
        8,19,10,19,12,19,395,9,19,1,19,1,19,1,20,1,20,1,21,1,21,1,21,1,21,
        1,21,5,21,406,8,21,10,21,12,21,409,9,21,1,21,1,21,3,21,413,8,21,
        1,22,1,22,1,22,1,22,3,22,419,8,22,1,22,1,22,3,22,423,8,22,1,22,1,
        22,1,22,1,22,1,22,1,22,5,22,431,8,22,10,22,12,22,434,9,22,1,22,1,
        22,1,22,1,22,1,22,3,22,441,8,22,1,22,1,22,3,22,445,8,22,1,23,1,23,
        1,23,1,23,3,23,451,8,23,1,23,3,23,454,8,23,1,23,1,23,5,23,458,8,
        23,10,23,12,23,461,9,23,1,23,1,23,3,23,465,8,23,1,24,1,24,1,24,3,
        24,470,8,24,1,24,1,24,1,24,1,24,1,24,1,24,5,24,478,8,24,10,24,12,
        24,481,9,24,1,24,1,24,1,24,1,24,1,24,3,24,488,8,24,1,24,1,24,3,24,
        492,8,24,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,5,25,502,8,25,10,
        25,12,25,505,9,25,1,25,1,25,3,25,509,8,25,1,26,1,26,1,26,1,26,4,
        26,515,8,26,11,26,12,26,516,1,26,1,26,1,27,1,27,1,27,1,27,1,28,1,
        28,1,28,1,28,1,28,1,28,5,28,531,8,28,10,28,12,28,534,9,28,1,28,1,
        28,1,29,1,29,1,29,1,29,1,29,1,29,1,30,1,30,1,30,1,30,1,30,1,30,1,
        30,5,30,551,8,30,10,30,12,30,554,9,30,1,30,1,30,1,30,3,30,559,8,
        30,1,30,1,30,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,32,1,32,3,32,572,
        8,32,1,32,3,32,575,8,32,1,33,1,33,1,33,1,33,1,33,1,33,5,33,583,8,
        33,10,33,12,33,586,9,33,3,33,588,8,33,1,33,1,33,3,33,592,8,33,1,
        33,1,33,1,34,1,34,3,34,598,8,34,1,35,1,35,1,35,1,35,1,35,1,35,5,
        35,606,8,35,10,35,12,35,609,9,35,3,35,611,8,35,1,35,1,35,1,35,1,
        36,1,36,1,37,1,37,1,37,1,37,1,37,1,37,5,37,624,8,37,10,37,12,37,
        627,9,37,1,37,1,37,3,37,631,8,37,1,37,1,37,1,37,3,37,636,8,37,1,
        37,3,37,639,8,37,1,37,1,37,1,38,1,38,1,38,3,38,646,8,38,1,39,1,39,
        1,39,1,39,1,39,3,39,653,8,39,1,39,1,39,1,39,3,39,658,8,39,1,39,5,
        39,661,8,39,10,39,12,39,664,9,39,1,40,1,40,1,40,1,40,1,40,1,40,1,
        40,1,40,1,40,1,40,1,40,3,40,677,8,40,1,41,1,41,1,41,3,41,682,8,41,
        1,41,1,41,1,41,5,41,687,8,41,10,41,12,41,690,9,41,1,41,1,41,1,41,
        1,41,1,41,3,41,697,8,41,1,42,1,42,3,42,701,8,42,1,42,1,42,1,43,1,
        43,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,
        44,1,44,1,44,1,44,1,44,1,44,3,44,725,8,44,3,44,727,8,44,1,44,1,44,
        1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,
        1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,
        1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,
        1,44,1,44,1,44,1,44,1,44,3,44,775,8,44,1,44,1,44,1,44,1,44,3,44,
        781,8,44,1,44,1,44,3,44,785,8,44,1,44,1,44,1,44,1,44,1,44,3,44,792,
        8,44,1,44,1,44,1,44,1,44,1,44,5,44,799,8,44,10,44,12,44,802,9,44,
        3,44,804,8,44,1,44,1,44,1,44,1,44,1,44,5,44,811,8,44,10,44,12,44,
        814,9,44,1,45,1,45,1,46,1,46,3,46,820,8,46,1,46,1,46,3,46,824,8,
        46,5,46,826,8,46,10,46,12,46,829,9,46,1,46,1,46,1,47,1,47,1,47,1,
        47,5,47,837,8,47,10,47,12,47,840,9,47,1,47,1,47,1,48,1,48,1,49,1,
        49,1,49,1,49,1,49,3,49,851,8,49,1,50,1,50,1,50,1,51,1,51,1,52,4,
        52,859,8,52,11,52,12,52,860,1,53,4,53,864,8,53,11,53,12,53,865,1,
        54,4,54,869,8,54,11,54,12,54,870,1,55,1,55,1,56,1,56,1,56,5,56,878,
        8,56,10,56,12,56,881,9,56,1,56,1,56,1,57,1,57,1,57,1,58,1,58,1,58,
        1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,3,58,901,8,58,
        1,59,1,59,3,59,905,8,59,1,60,1,60,1,60,1,60,1,60,1,60,1,60,3,60,
        914,8,60,1,61,1,61,1,61,1,61,3,61,920,8,61,1,61,1,61,3,61,924,8,
        61,1,61,3,61,927,8,61,1,61,1,61,1,61,1,62,1,62,1,62,1,62,1,62,1,
        62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,64,1,64,1,64,1,65,1,
        65,1,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,959,8,66,1,66,1,
        66,4,66,963,8,66,11,66,12,66,964,1,67,1,67,3,67,969,8,67,1,67,1,
        67,1,67,1,67,3,67,975,8,67,1,67,1,67,1,68,1,68,3,68,981,8,68,1,68,
        1,68,1,69,1,69,1,69,1,69,1,69,1,70,1,70,1,70,1,70,1,70,1,71,1,71,
        3,71,997,8,71,1,71,3,71,1000,8,71,1,71,1,71,5,71,1004,8,71,10,71,
        12,71,1007,9,71,1,71,1,71,1,72,1,72,1,72,1,72,5,72,1015,8,72,10,
        72,12,72,1018,9,72,1,72,1,72,1,73,1,73,1,73,5,73,1025,8,73,10,73,
        12,73,1028,9,73,1,74,1,74,5,74,1032,8,74,10,74,12,74,1035,9,74,1,
        74,1,74,1,74,1,74,3,74,1041,8,74,5,74,1043,8,74,10,74,12,74,1046,
        9,74,1,74,1,74,1,75,1,75,1,75,3,75,1053,8,75,1,75,1,75,1,75,1,75,
        3,75,1059,8,75,1,75,1,75,1,76,1,76,1,76,1,77,1,77,1,77,1,77,3,77,
        1070,8,77,1,77,1,77,1,77,3,77,1075,8,77,1,77,1,77,1,78,1,78,3,78,
        1081,8,78,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,
        3,79,1094,8,79,1,80,1,80,5,80,1098,8,80,10,80,12,80,1101,9,80,1,
        80,1,80,1,81,1,81,1,81,1,81,3,81,1109,8,81,1,81,1,81,1,81,1,81,5,
        81,1115,8,81,10,81,12,81,1118,9,81,1,81,1,81,3,81,1122,8,81,3,81,
        1124,8,81,1,82,1,82,1,82,1,82,1,82,1,82,1,82,4,82,1133,8,82,11,82,
        12,82,1134,1,82,1,82,1,82,3,82,1140,8,82,1,83,1,83,1,83,1,83,1,84,
        1,84,1,84,1,84,1,84,1,84,1,85,1,85,1,85,1,85,1,86,1,86,1,86,4,86,
        1159,8,86,11,86,12,86,1160,1,86,1,86,3,86,1165,8,86,1,86,1,86,3,
        86,1169,8,86,1,87,1,87,1,87,1,87,1,87,1,87,5,87,1177,8,87,10,87,
        12,87,1180,9,87,3,87,1182,8,87,1,87,1,87,1,87,1,87,1,87,5,87,1189,
        8,87,10,87,12,87,1192,9,87,3,87,1194,8,87,1,87,1,87,1,88,1,88,1,
        88,5,88,1201,8,88,10,88,12,88,1204,9,88,1,89,1,89,1,89,1,89,1,89,
        5,89,1211,8,89,10,89,12,89,1214,9,89,3,89,1216,8,89,1,89,1,89,1,
        90,1,90,1,91,1,91,1,91,1,91,1,91,3,91,1227,8,91,1,92,1,92,1,92,3,
        92,1232,8,92,1,92,1,300,2,78,88,93,0,2,4,6,8,10,12,14,16,18,20,22,
        24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
        68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
        108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,
        140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,
        172,174,176,178,180,182,184,0,18,3,0,23,23,38,38,49,50,3,0,47,47,
        51,51,68,68,4,0,98,100,104,108,110,115,117,117,3,0,10,10,42,42,57,
        57,3,0,16,16,105,105,116,119,1,0,106,108,1,0,104,105,1,0,101,103,
        1,0,112,115,1,0,110,111,1,0,118,119,1,0,83,94,5,0,21,21,29,29,31,
        31,55,55,130,130,2,0,25,25,60,60,1,0,122,123,2,0,126,126,128,128,
        2,0,156,156,165,165,2,0,147,147,154,154,1380,0,201,1,0,0,0,2,206,
        1,0,0,0,4,214,1,0,0,0,6,234,1,0,0,0,8,239,1,0,0,0,10,241,1,0,0,0,
        12,253,1,0,0,0,14,269,1,0,0,0,16,283,1,0,0,0,18,294,1,0,0,0,20,303,
        1,0,0,0,22,319,1,0,0,0,24,321,1,0,0,0,26,325,1,0,0,0,28,352,1,0,
        0,0,30,360,1,0,0,0,32,364,1,0,0,0,34,366,1,0,0,0,36,374,1,0,0,0,
        38,381,1,0,0,0,40,398,1,0,0,0,42,400,1,0,0,0,44,414,1,0,0,0,46,446,
        1,0,0,0,48,466,1,0,0,0,50,493,1,0,0,0,52,510,1,0,0,0,54,520,1,0,
        0,0,56,524,1,0,0,0,58,537,1,0,0,0,60,543,1,0,0,0,62,562,1,0,0,0,
        64,569,1,0,0,0,66,576,1,0,0,0,68,595,1,0,0,0,70,599,1,0,0,0,72,615,
        1,0,0,0,74,617,1,0,0,0,76,642,1,0,0,0,78,652,1,0,0,0,80,676,1,0,
        0,0,82,678,1,0,0,0,84,698,1,0,0,0,86,704,1,0,0,0,88,726,1,0,0,0,
        90,815,1,0,0,0,92,817,1,0,0,0,94,832,1,0,0,0,96,843,1,0,0,0,98,850,
        1,0,0,0,100,852,1,0,0,0,102,855,1,0,0,0,104,858,1,0,0,0,106,863,
        1,0,0,0,108,868,1,0,0,0,110,872,1,0,0,0,112,874,1,0,0,0,114,884,
        1,0,0,0,116,900,1,0,0,0,118,904,1,0,0,0,120,906,1,0,0,0,122,915,
        1,0,0,0,124,931,1,0,0,0,126,937,1,0,0,0,128,945,1,0,0,0,130,948,
        1,0,0,0,132,951,1,0,0,0,134,966,1,0,0,0,136,978,1,0,0,0,138,984,
        1,0,0,0,140,989,1,0,0,0,142,994,1,0,0,0,144,1010,1,0,0,0,146,1021,
        1,0,0,0,148,1029,1,0,0,0,150,1058,1,0,0,0,152,1062,1,0,0,0,154,1065,
        1,0,0,0,156,1080,1,0,0,0,158,1093,1,0,0,0,160,1095,1,0,0,0,162,1123,
        1,0,0,0,164,1139,1,0,0,0,166,1141,1,0,0,0,168,1145,1,0,0,0,170,1151,
        1,0,0,0,172,1155,1,0,0,0,174,1170,1,0,0,0,176,1197,1,0,0,0,178,1205,
        1,0,0,0,180,1219,1,0,0,0,182,1226,1,0,0,0,184,1231,1,0,0,0,186,200,
        3,2,1,0,187,200,3,4,2,0,188,200,3,74,37,0,189,200,3,12,6,0,190,200,
        3,14,7,0,191,200,3,16,8,0,192,200,3,44,22,0,193,200,3,62,31,0,194,
        200,3,52,26,0,195,200,3,56,28,0,196,200,3,58,29,0,197,200,3,70,35,
        0,198,200,3,66,33,0,199,186,1,0,0,0,199,187,1,0,0,0,199,188,1,0,
        0,0,199,189,1,0,0,0,199,190,1,0,0,0,199,191,1,0,0,0,199,192,1,0,
        0,0,199,193,1,0,0,0,199,194,1,0,0,0,199,195,1,0,0,0,199,196,1,0,
        0,0,199,197,1,0,0,0,199,198,1,0,0,0,200,203,1,0,0,0,201,199,1,0,
        0,0,201,202,1,0,0,0,202,204,1,0,0,0,203,201,1,0,0,0,204,205,5,0,
        0,1,205,1,1,0,0,0,206,208,5,48,0,0,207,209,5,173,0,0,208,207,1,0,
        0,0,209,210,1,0,0,0,210,208,1,0,0,0,210,211,1,0,0,0,211,212,1,0,
        0,0,212,213,5,174,0,0,213,3,1,0,0,0,214,230,5,35,0,0,215,218,3,8,
        4,0,216,217,5,5,0,0,217,219,3,96,48,0,218,216,1,0,0,0,218,219,1,
        0,0,0,219,231,1,0,0,0,220,221,3,10,5,0,221,222,5,29,0,0,222,223,
        3,8,4,0,223,231,1,0,0,0,224,225,5,106,0,0,225,226,5,5,0,0,226,227,
        3,96,48,0,227,228,5,29,0,0,228,229,3,8,4,0,229,231,1,0,0,0,230,215,
        1,0,0,0,230,220,1,0,0,0,230,224,1,0,0,0,231,232,1,0,0,0,232,233,
        5,78,0,0,233,5,1,0,0,0,234,237,3,96,48,0,235,236,5,5,0,0,236,238,
        3,96,48,0,237,235,1,0,0,0,237,238,1,0,0,0,238,7,1,0,0,0,239,240,
        5,122,0,0,240,9,1,0,0,0,241,242,5,75,0,0,242,247,3,6,3,0,243,244,
        5,95,0,0,244,246,3,6,3,0,245,243,1,0,0,0,246,249,1,0,0,0,247,245,
        1,0,0,0,247,248,1,0,0,0,248,250,1,0,0,0,249,247,1,0,0,0,250,251,
        5,76,0,0,251,11,1,0,0,0,252,254,5,2,0,0,253,252,1,0,0,0,253,254,
        1,0,0,0,254,255,1,0,0,0,255,256,5,15,0,0,256,258,3,96,48,0,257,259,
        3,18,9,0,258,257,1,0,0,0,258,259,1,0,0,0,259,260,1,0,0,0,260,264,
        5,75,0,0,261,263,3,22,11,0,262,261,1,0,0,0,263,266,1,0,0,0,264,262,
        1,0,0,0,264,265,1,0,0,0,265,267,1,0,0,0,266,264,1,0,0,0,267,268,
        5,76,0,0,268,13,1,0,0,0,269,270,5,37,0,0,270,272,3,96,48,0,271,273,
        3,18,9,0,272,271,1,0,0,0,272,273,1,0,0,0,273,274,1,0,0,0,274,278,
        5,75,0,0,275,277,3,22,11,0,276,275,1,0,0,0,277,280,1,0,0,0,278,276,
        1,0,0,0,278,279,1,0,0,0,279,281,1,0,0,0,280,278,1,0,0,0,281,282,
        5,76,0,0,282,15,1,0,0,0,283,284,5,40,0,0,284,285,3,96,48,0,285,289,
        5,75,0,0,286,288,3,22,11,0,287,286,1,0,0,0,288,291,1,0,0,0,289,287,
        1,0,0,0,289,290,1,0,0,0,290,292,1,0,0,0,291,289,1,0,0,0,292,293,
        5,76,0,0,293,17,1,0,0,0,294,295,5,39,0,0,295,300,3,20,10,0,296,297,
        5,95,0,0,297,299,3,20,10,0,298,296,1,0,0,0,299,302,1,0,0,0,300,301,
        1,0,0,0,300,298,1,0,0,0,301,19,1,0,0,0,302,300,1,0,0,0,303,305,3,
        28,14,0,304,306,3,26,13,0,305,304,1,0,0,0,305,306,1,0,0,0,306,21,
        1,0,0,0,307,320,3,38,19,0,308,320,3,44,22,0,309,320,3,46,23,0,310,
        320,3,48,24,0,311,320,3,50,25,0,312,320,3,52,26,0,313,320,3,56,28,
        0,314,320,3,58,29,0,315,320,3,60,30,0,316,320,3,66,33,0,317,320,
        3,70,35,0,318,320,3,74,37,0,319,307,1,0,0,0,319,308,1,0,0,0,319,
        309,1,0,0,0,319,310,1,0,0,0,319,311,1,0,0,0,319,312,1,0,0,0,319,
        313,1,0,0,0,319,314,1,0,0,0,319,315,1,0,0,0,319,316,1,0,0,0,319,
        317,1,0,0,0,319,318,1,0,0,0,320,23,1,0,0,0,321,322,3,96,48,0,322,
        323,5,77,0,0,323,324,3,88,44,0,324,25,1,0,0,0,325,348,5,71,0,0,326,
        331,3,88,44,0,327,328,5,95,0,0,328,330,3,88,44,0,329,327,1,0,0,0,
        330,333,1,0,0,0,331,329,1,0,0,0,331,332,1,0,0,0,332,335,1,0,0,0,
        333,331,1,0,0,0,334,326,1,0,0,0,334,335,1,0,0,0,335,349,1,0,0,0,
        336,345,5,75,0,0,337,342,3,24,12,0,338,339,5,95,0,0,339,341,3,24,
        12,0,340,338,1,0,0,0,341,344,1,0,0,0,342,340,1,0,0,0,342,343,1,0,
        0,0,343,346,1,0,0,0,344,342,1,0,0,0,345,337,1,0,0,0,345,346,1,0,
        0,0,346,347,1,0,0,0,347,349,5,76,0,0,348,334,1,0,0,0,348,336,1,0,
        0,0,349,350,1,0,0,0,350,351,5,72,0,0,351,27,1,0,0,0,352,357,3,96,
        48,0,353,354,5,79,0,0,354,356,3,96,48,0,355,353,1,0,0,0,356,359,
        1,0,0,0,357,355,1,0,0,0,357,358,1,0,0,0,358,29,1,0,0,0,359,357,1,
        0,0,0,360,362,3,28,14,0,361,363,3,26,13,0,362,361,1,0,0,0,362,363,
        1,0,0,0,363,31,1,0,0,0,364,365,7,0,0,0,365,33,1,0,0,0,366,371,3,
        36,18,0,367,368,5,95,0,0,368,370,3,36,18,0,369,367,1,0,0,0,370,373,
        1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,35,1,0,0,0,373,371,1,
        0,0,0,374,376,3,78,39,0,375,377,3,86,43,0,376,375,1,0,0,0,376,377,
        1,0,0,0,377,379,1,0,0,0,378,380,3,96,48,0,379,378,1,0,0,0,379,380,
        1,0,0,0,380,37,1,0,0,0,381,382,5,13,0,0,382,384,5,71,0,0,383,385,
        3,34,17,0,384,383,1,0,0,0,384,385,1,0,0,0,385,386,1,0,0,0,386,393,
        5,72,0,0,387,392,3,30,15,0,388,392,5,47,0,0,389,392,5,38,0,0,390,
        392,5,50,0,0,391,387,1,0,0,0,391,388,1,0,0,0,391,389,1,0,0,0,391,
        390,1,0,0,0,392,395,1,0,0,0,393,391,1,0,0,0,393,394,1,0,0,0,394,
        396,1,0,0,0,395,393,1,0,0,0,396,397,3,112,56,0,397,39,1,0,0,0,398,
        399,7,1,0,0,399,41,1,0,0,0,400,412,5,46,0,0,401,402,5,71,0,0,402,
        407,3,28,14,0,403,404,5,95,0,0,404,406,3,28,14,0,405,403,1,0,0,0,
        406,409,1,0,0,0,407,405,1,0,0,0,407,408,1,0,0,0,408,410,1,0,0,0,
        409,407,1,0,0,0,410,411,5,72,0,0,411,413,1,0,0,0,412,401,1,0,0,0,
        412,413,1,0,0,0,413,43,1,0,0,0,414,418,5,30,0,0,415,419,3,96,48,
        0,416,419,5,24,0,0,417,419,5,52,0,0,418,415,1,0,0,0,418,416,1,0,
        0,0,418,417,1,0,0,0,419,420,1,0,0,0,420,422,5,71,0,0,421,423,3,34,
        17,0,422,421,1,0,0,0,422,423,1,0,0,0,423,424,1,0,0,0,424,432,5,72,
        0,0,425,431,3,32,16,0,426,431,3,40,20,0,427,431,3,30,15,0,428,431,
        5,69,0,0,429,431,3,42,21,0,430,425,1,0,0,0,430,426,1,0,0,0,430,427,
        1,0,0,0,430,428,1,0,0,0,430,429,1,0,0,0,431,434,1,0,0,0,432,430,
        1,0,0,0,432,433,1,0,0,0,433,440,1,0,0,0,434,432,1,0,0,0,435,436,
        5,54,0,0,436,437,5,71,0,0,437,438,3,34,17,0,438,439,5,72,0,0,439,
        441,1,0,0,0,440,435,1,0,0,0,440,441,1,0,0,0,441,444,1,0,0,0,442,
        445,5,78,0,0,443,445,3,112,56,0,444,442,1,0,0,0,444,443,1,0,0,0,
        445,45,1,0,0,0,446,447,5,43,0,0,447,453,3,96,48,0,448,450,5,71,0,
        0,449,451,3,34,17,0,450,449,1,0,0,0,450,451,1,0,0,0,451,452,1,0,
        0,0,452,454,5,72,0,0,453,448,1,0,0,0,453,454,1,0,0,0,454,459,1,0,
        0,0,455,458,5,69,0,0,456,458,3,42,21,0,457,455,1,0,0,0,457,456,1,
        0,0,0,458,461,1,0,0,0,459,457,1,0,0,0,459,460,1,0,0,0,460,464,1,
        0,0,0,461,459,1,0,0,0,462,465,5,78,0,0,463,465,3,112,56,0,464,462,
        1,0,0,0,464,463,1,0,0,0,465,47,1,0,0,0,466,467,5,24,0,0,467,469,
        5,71,0,0,468,470,3,34,17,0,469,468,1,0,0,0,469,470,1,0,0,0,470,471,
        1,0,0,0,471,479,5,72,0,0,472,478,5,23,0,0,473,478,3,40,20,0,474,
        478,3,30,15,0,475,478,5,69,0,0,476,478,3,42,21,0,477,472,1,0,0,0,
        477,473,1,0,0,0,477,474,1,0,0,0,477,475,1,0,0,0,477,476,1,0,0,0,
        478,481,1,0,0,0,479,477,1,0,0,0,479,480,1,0,0,0,480,487,1,0,0,0,
        481,479,1,0,0,0,482,483,5,54,0,0,483,484,5,71,0,0,484,485,3,34,17,
        0,485,486,5,72,0,0,486,488,1,0,0,0,487,482,1,0,0,0,487,488,1,0,0,
        0,488,491,1,0,0,0,489,492,5,78,0,0,490,492,3,112,56,0,491,489,1,
        0,0,0,491,490,1,0,0,0,492,49,1,0,0,0,493,494,5,52,0,0,494,495,5,
        71,0,0,495,503,5,72,0,0,496,502,5,23,0,0,497,502,5,47,0,0,498,502,
        3,30,15,0,499,502,5,69,0,0,500,502,3,42,21,0,501,496,1,0,0,0,501,
        497,1,0,0,0,501,498,1,0,0,0,501,499,1,0,0,0,501,500,1,0,0,0,502,
        505,1,0,0,0,503,501,1,0,0,0,503,504,1,0,0,0,504,508,1,0,0,0,505,
        503,1,0,0,0,506,509,5,78,0,0,507,509,3,112,56,0,508,506,1,0,0,0,
        508,507,1,0,0,0,509,51,1,0,0,0,510,511,5,59,0,0,511,512,3,96,48,
        0,512,514,5,75,0,0,513,515,3,54,27,0,514,513,1,0,0,0,515,516,1,0,
        0,0,516,514,1,0,0,0,516,517,1,0,0,0,517,518,1,0,0,0,518,519,5,76,
        0,0,519,53,1,0,0,0,520,521,3,78,39,0,521,522,3,96,48,0,522,523,5,
        78,0,0,523,55,1,0,0,0,524,525,5,20,0,0,525,526,3,96,48,0,526,527,
        5,75,0,0,527,532,3,96,48,0,528,529,5,95,0,0,529,531,3,96,48,0,530,
        528,1,0,0,0,531,534,1,0,0,0,532,530,1,0,0,0,532,533,1,0,0,0,533,
        535,1,0,0,0,534,532,1,0,0,0,535,536,5,76,0,0,536,57,1,0,0,0,537,
        538,5,62,0,0,538,539,3,96,48,0,539,540,5,39,0,0,540,541,3,80,40,
        0,541,542,5,78,0,0,542,59,1,0,0,0,543,552,3,78,39,0,544,551,5,50,
        0,0,545,551,5,49,0,0,546,551,5,38,0,0,547,551,5,12,0,0,548,551,3,
        42,21,0,549,551,5,34,0,0,550,544,1,0,0,0,550,545,1,0,0,0,550,546,
        1,0,0,0,550,547,1,0,0,0,550,548,1,0,0,0,550,549,1,0,0,0,551,554,
        1,0,0,0,552,550,1,0,0,0,552,553,1,0,0,0,553,555,1,0,0,0,554,552,
        1,0,0,0,555,558,3,96,48,0,556,557,5,83,0,0,557,559,3,88,44,0,558,
        556,1,0,0,0,558,559,1,0,0,0,559,560,1,0,0,0,560,561,5,78,0,0,561,
        61,1,0,0,0,562,563,3,78,39,0,563,564,5,12,0,0,564,565,3,96,48,0,
        565,566,5,83,0,0,566,567,3,88,44,0,567,568,5,78,0,0,568,63,1,0,0,
        0,569,571,3,78,39,0,570,572,5,36,0,0,571,570,1,0,0,0,571,572,1,0,
        0,0,572,574,1,0,0,0,573,575,3,96,48,0,574,573,1,0,0,0,574,575,1,
        0,0,0,575,65,1,0,0,0,576,577,5,22,0,0,577,578,3,96,48,0,578,587,
        5,71,0,0,579,584,3,64,32,0,580,581,5,95,0,0,581,583,3,64,32,0,582,
        580,1,0,0,0,583,586,1,0,0,0,584,582,1,0,0,0,584,585,1,0,0,0,585,
        588,1,0,0,0,586,584,1,0,0,0,587,579,1,0,0,0,587,588,1,0,0,0,588,
        589,1,0,0,0,589,591,5,72,0,0,590,592,5,4,0,0,591,590,1,0,0,0,591,
        592,1,0,0,0,592,593,1,0,0,0,593,594,5,78,0,0,594,67,1,0,0,0,595,
        597,3,78,39,0,596,598,3,96,48,0,597,596,1,0,0,0,597,598,1,0,0,0,
        598,69,1,0,0,0,599,600,5,21,0,0,600,601,3,96,48,0,601,610,5,71,0,
        0,602,607,3,68,34,0,603,604,5,95,0,0,604,606,3,68,34,0,605,603,1,
        0,0,0,606,609,1,0,0,0,607,605,1,0,0,0,607,608,1,0,0,0,608,611,1,
        0,0,0,609,607,1,0,0,0,610,602,1,0,0,0,610,611,1,0,0,0,611,612,1,
        0,0,0,612,613,5,72,0,0,613,614,5,78,0,0,614,71,1,0,0,0,615,616,7,
        2,0,0,616,73,1,0,0,0,617,630,5,67,0,0,618,631,3,28,14,0,619,620,
        5,75,0,0,620,625,3,76,38,0,621,622,5,95,0,0,622,624,3,76,38,0,623,
        621,1,0,0,0,624,627,1,0,0,0,625,623,1,0,0,0,625,626,1,0,0,0,626,
        628,1,0,0,0,627,625,1,0,0,0,628,629,5,76,0,0,629,631,1,0,0,0,630,
        618,1,0,0,0,630,619,1,0,0,0,631,632,1,0,0,0,632,635,5,28,0,0,633,
        636,5,106,0,0,634,636,3,78,39,0,635,633,1,0,0,0,635,634,1,0,0,0,
        636,638,1,0,0,0,637,639,5,31,0,0,638,637,1,0,0,0,638,639,1,0,0,0,
        639,640,1,0,0,0,640,641,5,78,0,0,641,75,1,0,0,0,642,645,3,28,14,
        0,643,644,5,5,0,0,644,646,3,72,36,0,645,643,1,0,0,0,645,646,1,0,
        0,0,646,77,1,0,0,0,647,648,6,39,-1,0,648,653,3,80,40,0,649,653,3,
        82,41,0,650,653,3,154,77,0,651,653,3,28,14,0,652,647,1,0,0,0,652,
        649,1,0,0,0,652,650,1,0,0,0,652,651,1,0,0,0,653,662,1,0,0,0,654,
        655,10,1,0,0,655,657,5,73,0,0,656,658,3,88,44,0,657,656,1,0,0,0,
        657,658,1,0,0,0,658,659,1,0,0,0,659,661,5,74,0,0,660,654,1,0,0,0,
        661,664,1,0,0,0,662,660,1,0,0,0,662,663,1,0,0,0,663,79,1,0,0,0,664,
        662,1,0,0,0,665,677,5,3,0,0,666,667,5,3,0,0,667,677,5,47,0,0,668,
        677,5,7,0,0,669,677,5,58,0,0,670,677,5,9,0,0,671,677,5,56,0,0,672,
        677,5,66,0,0,673,677,5,27,0,0,674,677,5,26,0,0,675,677,5,63,0,0,
        676,665,1,0,0,0,676,666,1,0,0,0,676,668,1,0,0,0,676,669,1,0,0,0,
        676,670,1,0,0,0,676,671,1,0,0,0,676,672,1,0,0,0,676,673,1,0,0,0,
        676,674,1,0,0,0,676,675,1,0,0,0,677,81,1,0,0,0,678,679,5,30,0,0,
        679,681,5,71,0,0,680,682,3,34,17,0,681,680,1,0,0,0,681,682,1,0,0,
        0,682,683,1,0,0,0,683,688,5,72,0,0,684,687,3,32,16,0,685,687,3,40,
        20,0,686,684,1,0,0,0,686,685,1,0,0,0,687,690,1,0,0,0,688,686,1,0,
        0,0,688,689,1,0,0,0,689,696,1,0,0,0,690,688,1,0,0,0,691,692,5,54,
        0,0,692,693,5,71,0,0,693,694,3,34,17,0,694,695,5,72,0,0,695,697,
        1,0,0,0,696,691,1,0,0,0,696,697,1,0,0,0,697,83,1,0,0,0,698,700,3,
        78,39,0,699,701,3,86,43,0,700,699,1,0,0,0,700,701,1,0,0,0,701,702,
        1,0,0,0,702,703,3,96,48,0,703,85,1,0,0,0,704,705,7,3,0,0,705,87,
        1,0,0,0,706,707,6,44,-1,0,707,708,5,47,0,0,708,727,3,26,13,0,709,
        710,5,62,0,0,710,711,5,71,0,0,711,712,3,78,39,0,712,713,5,72,0,0,
        713,727,1,0,0,0,714,715,7,4,0,0,715,727,3,88,44,19,716,717,5,44,
        0,0,717,727,3,78,39,0,718,727,3,92,46,0,719,727,3,94,47,0,720,725,
        3,96,48,0,721,725,3,98,49,0,722,725,3,100,50,0,723,725,3,80,40,0,
        724,720,1,0,0,0,724,721,1,0,0,0,724,722,1,0,0,0,724,723,1,0,0,0,
        725,727,1,0,0,0,726,706,1,0,0,0,726,709,1,0,0,0,726,714,1,0,0,0,
        726,716,1,0,0,0,726,718,1,0,0,0,726,719,1,0,0,0,726,724,1,0,0,0,
        727,812,1,0,0,0,728,729,10,17,0,0,729,730,5,109,0,0,730,811,3,88,
        44,17,731,732,10,16,0,0,732,733,7,5,0,0,733,811,3,88,44,17,734,735,
        10,15,0,0,735,736,7,6,0,0,736,811,3,88,44,16,737,738,10,14,0,0,738,
        739,7,7,0,0,739,811,3,88,44,15,740,741,10,13,0,0,741,742,5,100,0,
        0,742,811,3,88,44,14,743,744,10,12,0,0,744,745,5,99,0,0,745,811,
        3,88,44,13,746,747,10,11,0,0,747,748,5,98,0,0,748,811,3,88,44,12,
        749,750,10,10,0,0,750,751,7,8,0,0,751,811,3,88,44,11,752,753,10,
        9,0,0,753,754,7,9,0,0,754,811,3,88,44,10,755,756,10,8,0,0,756,757,
        5,97,0,0,757,811,3,88,44,9,758,759,10,7,0,0,759,760,5,96,0,0,760,
        811,3,88,44,8,761,762,10,6,0,0,762,763,5,80,0,0,763,764,3,88,44,
        0,764,765,5,77,0,0,765,766,3,88,44,6,766,811,1,0,0,0,767,768,10,
        5,0,0,768,769,3,90,45,0,769,770,3,88,44,5,770,811,1,0,0,0,771,772,
        10,26,0,0,772,774,5,73,0,0,773,775,3,88,44,0,774,773,1,0,0,0,774,
        775,1,0,0,0,775,776,1,0,0,0,776,811,5,74,0,0,777,778,10,25,0,0,778,
        780,5,73,0,0,779,781,3,88,44,0,780,779,1,0,0,0,780,781,1,0,0,0,781,
        782,1,0,0,0,782,784,5,77,0,0,783,785,3,88,44,0,784,783,1,0,0,0,784,
        785,1,0,0,0,785,786,1,0,0,0,786,811,5,74,0,0,787,788,10,24,0,0,788,
        791,5,79,0,0,789,792,3,96,48,0,790,792,5,3,0,0,791,789,1,0,0,0,791,
        790,1,0,0,0,792,811,1,0,0,0,793,794,10,23,0,0,794,803,5,75,0,0,795,
        800,3,24,12,0,796,797,5,95,0,0,797,799,3,24,12,0,798,796,1,0,0,0,
        799,802,1,0,0,0,800,798,1,0,0,0,800,801,1,0,0,0,801,804,1,0,0,0,
        802,800,1,0,0,0,803,795,1,0,0,0,803,804,1,0,0,0,804,805,1,0,0,0,
        805,811,5,76,0,0,806,807,10,22,0,0,807,811,3,26,13,0,808,809,10,
        18,0,0,809,811,7,10,0,0,810,728,1,0,0,0,810,731,1,0,0,0,810,734,
        1,0,0,0,810,737,1,0,0,0,810,740,1,0,0,0,810,743,1,0,0,0,810,746,
        1,0,0,0,810,749,1,0,0,0,810,752,1,0,0,0,810,755,1,0,0,0,810,758,
        1,0,0,0,810,761,1,0,0,0,810,767,1,0,0,0,810,771,1,0,0,0,810,777,
        1,0,0,0,810,787,1,0,0,0,810,793,1,0,0,0,810,806,1,0,0,0,810,808,
        1,0,0,0,811,814,1,0,0,0,812,810,1,0,0,0,812,813,1,0,0,0,813,89,1,
        0,0,0,814,812,1,0,0,0,815,816,7,11,0,0,816,91,1,0,0,0,817,819,5,
        71,0,0,818,820,3,88,44,0,819,818,1,0,0,0,819,820,1,0,0,0,820,827,
        1,0,0,0,821,823,5,95,0,0,822,824,3,88,44,0,823,822,1,0,0,0,823,824,
        1,0,0,0,824,826,1,0,0,0,825,821,1,0,0,0,826,829,1,0,0,0,827,825,
        1,0,0,0,827,828,1,0,0,0,828,830,1,0,0,0,829,827,1,0,0,0,830,831,
        5,72,0,0,831,93,1,0,0,0,832,833,5,73,0,0,833,838,3,88,44,0,834,835,
        5,95,0,0,835,837,3,88,44,0,836,834,1,0,0,0,837,840,1,0,0,0,838,836,
        1,0,0,0,838,839,1,0,0,0,839,841,1,0,0,0,840,838,1,0,0,0,841,842,
        5,74,0,0,842,95,1,0,0,0,843,844,7,12,0,0,844,97,1,0,0,0,845,851,
        3,104,52,0,846,851,3,110,55,0,847,851,3,102,51,0,848,851,3,106,53,
        0,849,851,3,108,54,0,850,845,1,0,0,0,850,846,1,0,0,0,850,847,1,0,
        0,0,850,848,1,0,0,0,850,849,1,0,0,0,851,99,1,0,0,0,852,853,3,110,
        55,0,853,854,5,45,0,0,854,101,1,0,0,0,855,856,7,13,0,0,856,103,1,
        0,0,0,857,859,7,14,0,0,858,857,1,0,0,0,859,860,1,0,0,0,860,858,1,
        0,0,0,860,861,1,0,0,0,861,105,1,0,0,0,862,864,5,125,0,0,863,862,
        1,0,0,0,864,865,1,0,0,0,865,863,1,0,0,0,865,866,1,0,0,0,866,107,
        1,0,0,0,867,869,5,124,0,0,868,867,1,0,0,0,869,870,1,0,0,0,870,868,
        1,0,0,0,870,871,1,0,0,0,871,109,1,0,0,0,872,873,7,15,0,0,873,111,
        1,0,0,0,874,879,5,75,0,0,875,878,3,116,58,0,876,878,3,114,57,0,877,
        875,1,0,0,0,877,876,1,0,0,0,878,881,1,0,0,0,879,877,1,0,0,0,879,
        880,1,0,0,0,880,882,1,0,0,0,881,879,1,0,0,0,882,883,5,76,0,0,883,
        113,1,0,0,0,884,885,5,64,0,0,885,886,3,112,56,0,886,115,1,0,0,0,
        887,901,3,112,56,0,888,901,3,118,59,0,889,901,3,120,60,0,890,901,
        3,122,61,0,891,901,3,124,62,0,892,901,3,126,63,0,893,901,3,128,64,
        0,894,901,3,130,65,0,895,901,3,132,66,0,896,901,3,136,68,0,897,901,
        3,138,69,0,898,901,3,140,70,0,899,901,3,142,71,0,900,887,1,0,0,0,
        900,888,1,0,0,0,900,889,1,0,0,0,900,890,1,0,0,0,900,891,1,0,0,0,
        900,892,1,0,0,0,900,893,1,0,0,0,900,894,1,0,0,0,900,895,1,0,0,0,
        900,896,1,0,0,0,900,897,1,0,0,0,900,898,1,0,0,0,900,899,1,0,0,0,
        901,117,1,0,0,0,902,905,3,150,75,0,903,905,3,152,76,0,904,902,1,
        0,0,0,904,903,1,0,0,0,905,119,1,0,0,0,906,907,5,33,0,0,907,908,5,
        71,0,0,908,909,3,88,44,0,909,910,5,72,0,0,910,913,3,116,58,0,911,
        912,5,18,0,0,912,914,3,116,58,0,913,911,1,0,0,0,913,914,1,0,0,0,
        914,121,1,0,0,0,915,916,5,28,0,0,916,919,5,71,0,0,917,920,3,118,
        59,0,918,920,5,78,0,0,919,917,1,0,0,0,919,918,1,0,0,0,920,923,1,
        0,0,0,921,924,3,152,76,0,922,924,5,78,0,0,923,921,1,0,0,0,923,922,
        1,0,0,0,924,926,1,0,0,0,925,927,3,88,44,0,926,925,1,0,0,0,926,927,
        1,0,0,0,927,928,1,0,0,0,928,929,5,72,0,0,929,930,3,116,58,0,930,
        123,1,0,0,0,931,932,5,70,0,0,932,933,5,71,0,0,933,934,3,88,44,0,
        934,935,5,72,0,0,935,936,3,116,58,0,936,125,1,0,0,0,937,938,5,17,
        0,0,938,939,3,116,58,0,939,940,5,70,0,0,940,941,5,71,0,0,941,942,
        3,88,44,0,942,943,5,72,0,0,943,944,5,78,0,0,944,127,1,0,0,0,945,
        946,5,14,0,0,946,947,5,78,0,0,947,129,1,0,0,0,948,949,5,8,0,0,949,
        950,5,78,0,0,950,131,1,0,0,0,951,952,5,61,0,0,952,958,3,88,44,0,
        953,954,5,54,0,0,954,955,5,71,0,0,955,956,3,34,17,0,956,957,5,72,
        0,0,957,959,1,0,0,0,958,953,1,0,0,0,958,959,1,0,0,0,959,960,1,0,
        0,0,960,962,3,112,56,0,961,963,3,134,67,0,962,961,1,0,0,0,963,964,
        1,0,0,0,964,962,1,0,0,0,964,965,1,0,0,0,965,133,1,0,0,0,966,974,
        5,11,0,0,967,969,3,96,48,0,968,967,1,0,0,0,968,969,1,0,0,0,969,970,
        1,0,0,0,970,971,5,71,0,0,971,972,3,34,17,0,972,973,5,72,0,0,973,
        975,1,0,0,0,974,968,1,0,0,0,974,975,1,0,0,0,975,976,1,0,0,0,976,
        977,3,112,56,0,977,135,1,0,0,0,978,980,5,53,0,0,979,981,3,88,44,
        0,980,979,1,0,0,0,980,981,1,0,0,0,981,982,1,0,0,0,982,983,5,78,0,
        0,983,137,1,0,0,0,984,985,5,19,0,0,985,986,3,88,44,0,986,987,3,26,
        13,0,987,988,5,78,0,0,988,139,1,0,0,0,989,990,5,55,0,0,990,991,3,
        88,44,0,991,992,3,26,13,0,992,993,5,78,0,0,993,141,1,0,0,0,994,996,
        5,6,0,0,995,997,5,134,0,0,996,995,1,0,0,0,996,997,1,0,0,0,997,999,
        1,0,0,0,998,1000,3,144,72,0,999,998,1,0,0,0,999,1000,1,0,0,0,1000,
        1001,1,0,0,0,1001,1005,5,135,0,0,1002,1004,3,158,79,0,1003,1002,
        1,0,0,0,1004,1007,1,0,0,0,1005,1003,1,0,0,0,1005,1006,1,0,0,0,1006,
        1008,1,0,0,0,1007,1005,1,0,0,0,1008,1009,5,158,0,0,1009,143,1,0,
        0,0,1010,1011,5,137,0,0,1011,1016,5,136,0,0,1012,1013,5,139,0,0,
        1013,1015,5,136,0,0,1014,1012,1,0,0,0,1015,1018,1,0,0,0,1016,1014,
        1,0,0,0,1016,1017,1,0,0,0,1017,1019,1,0,0,0,1018,1016,1,0,0,0,1019,
        1020,5,138,0,0,1020,145,1,0,0,0,1021,1026,3,84,42,0,1022,1023,5,
        95,0,0,1023,1025,3,84,42,0,1024,1022,1,0,0,0,1025,1028,1,0,0,0,1026,
        1024,1,0,0,0,1026,1027,1,0,0,0,1027,147,1,0,0,0,1028,1026,1,0,0,
        0,1029,1033,5,71,0,0,1030,1032,5,95,0,0,1031,1030,1,0,0,0,1032,1035,
        1,0,0,0,1033,1031,1,0,0,0,1033,1034,1,0,0,0,1034,1036,1,0,0,0,1035,
        1033,1,0,0,0,1036,1037,3,84,42,0,1037,1044,1,0,0,0,1038,1040,5,95,
        0,0,1039,1041,3,84,42,0,1040,1039,1,0,0,0,1040,1041,1,0,0,0,1041,
        1043,1,0,0,0,1042,1038,1,0,0,0,1043,1046,1,0,0,0,1044,1042,1,0,0,
        0,1044,1045,1,0,0,0,1045,1047,1,0,0,0,1046,1044,1,0,0,0,1047,1048,
        5,72,0,0,1048,149,1,0,0,0,1049,1052,3,84,42,0,1050,1051,5,83,0,0,
        1051,1053,3,88,44,0,1052,1050,1,0,0,0,1052,1053,1,0,0,0,1053,1059,
        1,0,0,0,1054,1055,3,148,74,0,1055,1056,5,83,0,0,1056,1057,3,88,44,
        0,1057,1059,1,0,0,0,1058,1049,1,0,0,0,1058,1054,1,0,0,0,1059,1060,
        1,0,0,0,1060,1061,5,78,0,0,1061,151,1,0,0,0,1062,1063,3,88,44,0,
        1063,1064,5,78,0,0,1064,153,1,0,0,0,1065,1066,5,41,0,0,1066,1067,
        5,71,0,0,1067,1069,3,156,78,0,1068,1070,3,96,48,0,1069,1068,1,0,
        0,0,1069,1070,1,0,0,0,1070,1071,1,0,0,0,1071,1072,5,81,0,0,1072,
        1074,3,78,39,0,1073,1075,3,96,48,0,1074,1073,1,0,0,0,1074,1075,1,
        0,0,0,1075,1076,1,0,0,0,1076,1077,5,72,0,0,1077,155,1,0,0,0,1078,
        1081,3,80,40,0,1079,1081,3,28,14,0,1080,1078,1,0,0,0,1080,1079,1,
        0,0,0,1081,157,1,0,0,0,1082,1094,3,160,80,0,1083,1094,3,162,81,0,
        1084,1094,3,164,82,0,1085,1094,3,178,89,0,1086,1094,3,166,83,0,1087,
        1094,3,168,84,0,1088,1094,3,172,86,0,1089,1094,5,151,0,0,1090,1094,
        5,143,0,0,1091,1094,5,145,0,0,1092,1094,3,174,87,0,1093,1082,1,0,
        0,0,1093,1083,1,0,0,0,1093,1084,1,0,0,0,1093,1085,1,0,0,0,1093,1086,
        1,0,0,0,1093,1087,1,0,0,0,1093,1088,1,0,0,0,1093,1089,1,0,0,0,1093,
        1090,1,0,0,0,1093,1091,1,0,0,0,1093,1092,1,0,0,0,1094,159,1,0,0,
        0,1095,1099,5,157,0,0,1096,1098,3,158,79,0,1097,1096,1,0,0,0,1098,
        1101,1,0,0,0,1099,1097,1,0,0,0,1099,1100,1,0,0,0,1100,1102,1,0,0,
        0,1101,1099,1,0,0,0,1102,1103,5,158,0,0,1103,161,1,0,0,0,1104,1105,
        5,152,0,0,1105,1108,5,165,0,0,1106,1107,5,161,0,0,1107,1109,3,184,
        92,0,1108,1106,1,0,0,0,1108,1109,1,0,0,0,1109,1124,1,0,0,0,1110,
        1111,5,152,0,0,1111,1116,5,165,0,0,1112,1113,5,163,0,0,1113,1115,
        5,165,0,0,1114,1112,1,0,0,0,1115,1118,1,0,0,0,1116,1114,1,0,0,0,
        1116,1117,1,0,0,0,1117,1121,1,0,0,0,1118,1116,1,0,0,0,1119,1120,
        5,161,0,0,1120,1122,3,178,89,0,1121,1119,1,0,0,0,1121,1122,1,0,0,
        0,1122,1124,1,0,0,0,1123,1104,1,0,0,0,1123,1110,1,0,0,0,1124,163,
        1,0,0,0,1125,1126,3,176,88,0,1126,1127,5,161,0,0,1127,1128,3,184,
        92,0,1128,1140,1,0,0,0,1129,1132,3,176,88,0,1130,1131,5,163,0,0,
        1131,1133,3,176,88,0,1132,1130,1,0,0,0,1133,1134,1,0,0,0,1134,1132,
        1,0,0,0,1134,1135,1,0,0,0,1135,1136,1,0,0,0,1136,1137,5,161,0,0,
        1137,1138,3,178,89,0,1138,1140,1,0,0,0,1139,1125,1,0,0,0,1139,1129,
        1,0,0,0,1140,165,1,0,0,0,1141,1142,5,150,0,0,1142,1143,3,184,92,
        0,1143,1144,3,160,80,0,1144,167,1,0,0,0,1145,1146,5,148,0,0,1146,
        1147,3,160,80,0,1147,1148,3,184,92,0,1148,1149,3,160,80,0,1149,1150,
        3,160,80,0,1150,169,1,0,0,0,1151,1152,5,144,0,0,1152,1153,3,182,
        91,0,1153,1154,3,160,80,0,1154,171,1,0,0,0,1155,1156,5,153,0,0,1156,
        1168,3,184,92,0,1157,1159,3,170,85,0,1158,1157,1,0,0,0,1159,1160,
        1,0,0,0,1160,1158,1,0,0,0,1160,1161,1,0,0,0,1161,1164,1,0,0,0,1162,
        1163,5,146,0,0,1163,1165,3,160,80,0,1164,1162,1,0,0,0,1164,1165,
        1,0,0,0,1165,1169,1,0,0,0,1166,1167,5,146,0,0,1167,1169,3,160,80,
        0,1168,1158,1,0,0,0,1168,1166,1,0,0,0,1169,173,1,0,0,0,1170,1171,
        5,149,0,0,1171,1172,5,165,0,0,1172,1181,5,159,0,0,1173,1178,5,165,
        0,0,1174,1175,5,163,0,0,1175,1177,5,165,0,0,1176,1174,1,0,0,0,1177,
        1180,1,0,0,0,1178,1176,1,0,0,0,1178,1179,1,0,0,0,1179,1182,1,0,0,
        0,1180,1178,1,0,0,0,1181,1173,1,0,0,0,1181,1182,1,0,0,0,1182,1183,
        1,0,0,0,1183,1193,5,160,0,0,1184,1185,5,164,0,0,1185,1190,5,165,
        0,0,1186,1187,5,163,0,0,1187,1189,5,165,0,0,1188,1186,1,0,0,0,1189,
        1192,1,0,0,0,1190,1188,1,0,0,0,1190,1191,1,0,0,0,1191,1194,1,0,0,
        0,1192,1190,1,0,0,0,1193,1184,1,0,0,0,1193,1194,1,0,0,0,1194,1195,
        1,0,0,0,1195,1196,3,160,80,0,1196,175,1,0,0,0,1197,1202,5,165,0,
        0,1198,1199,5,162,0,0,1199,1201,7,16,0,0,1200,1198,1,0,0,0,1201,
        1204,1,0,0,0,1202,1200,1,0,0,0,1202,1203,1,0,0,0,1203,177,1,0,0,
        0,1204,1202,1,0,0,0,1205,1206,7,16,0,0,1206,1215,5,159,0,0,1207,
        1212,3,184,92,0,1208,1209,5,163,0,0,1209,1211,3,184,92,0,1210,1208,
        1,0,0,0,1211,1214,1,0,0,0,1212,1210,1,0,0,0,1212,1213,1,0,0,0,1213,
        1216,1,0,0,0,1214,1212,1,0,0,0,1215,1207,1,0,0,0,1215,1216,1,0,0,
        0,1216,1217,1,0,0,0,1217,1218,5,160,0,0,1218,179,1,0,0,0,1219,1220,
        7,17,0,0,1220,181,1,0,0,0,1221,1227,5,167,0,0,1222,1227,5,168,0,
        0,1223,1227,5,166,0,0,1224,1227,3,180,90,0,1225,1227,5,169,0,0,1226,
        1221,1,0,0,0,1226,1222,1,0,0,0,1226,1223,1,0,0,0,1226,1224,1,0,0,
        0,1226,1225,1,0,0,0,1227,183,1,0,0,0,1228,1232,3,176,88,0,1229,1232,
        3,178,89,0,1230,1232,3,182,91,0,1231,1228,1,0,0,0,1231,1229,1,0,
        0,0,1231,1230,1,0,0,0,1232,185,1,0,0,0,141,199,201,210,218,230,237,
        247,253,258,264,272,278,289,300,305,319,331,334,342,345,348,357,
        362,371,376,379,384,391,393,407,412,418,422,430,432,440,444,450,
        453,457,459,464,469,477,479,487,491,501,503,508,516,532,550,552,
        558,571,574,584,587,591,597,607,610,625,630,635,638,645,652,657,
        662,676,681,686,688,696,700,724,726,774,780,784,791,800,803,810,
        812,819,823,827,838,850,860,865,870,877,879,900,904,913,919,923,
        926,958,964,968,974,980,996,999,1005,1016,1026,1033,1040,1044,1052,
        1058,1069,1074,1080,1093,1099,1108,1116,1121,1123,1134,1139,1160,
        1164,1168,1178,1181,1190,1193,1202,1212,1215,1226,1231
    ]

class SolidityParser ( Parser ):

    grammarFileName = "SolidityParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'abstract'", "'address'", 
                     "'anonymous'", "'as'", "'assembly'", "'bool'", "<INVALID>", 
                     "'bytes'", "'calldata'", "'catch'", "'constant'", "'constructor'", 
                     "<INVALID>", "'contract'", "'delete'", "'do'", "'else'", 
                     "'emit'", "'enum'", "'error'", "'event'", "'external'", 
                     "'fallback'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'from'", "<INVALID>", "'global'", "<INVALID>", 
                     "<INVALID>", "'immutable'", "'import'", "'indexed'", 
                     "'interface'", "'internal'", "'is'", "'library'", "'mapping'", 
                     "'memory'", "'modifier'", "'new'", "<INVALID>", "'override'", 
                     "'payable'", "'pragma'", "'private'", "'public'", "'pure'", 
                     "'receive'", "'return'", "'returns'", "'revert'", "<INVALID>", 
                     "'storage'", "'string'", "'struct'", "<INVALID>", "'try'", 
                     "'type'", "<INVALID>", "'unchecked'", "'unicode'", 
                     "<INVALID>", "'using'", "'view'", "'virtual'", "'while'", 
                     "<INVALID>", "<INVALID>", "'['", "']'", "<INVALID>", 
                     "<INVALID>", "':'", "<INVALID>", "<INVALID>", "'?'", 
                     "'=>'", "<INVALID>", "'='", "'|='", "'^='", "'&='", 
                     "'<<='", "'>>='", "'>>>='", "'+='", "'-='", "'*='", 
                     "'/='", "'%='", "<INVALID>", "'||'", "'&&'", "'|'", 
                     "'^'", "'&'", "'<<'", "'>>'", "'>>>'", "'+'", "'-'", 
                     "'*'", "'/'", "'%'", "'**'", "'=='", "'!='", "'<'", 
                     "'>'", "'<='", "'>='", "'!'", "'~'", "'++'", "'--'", 
                     "'\"'", "'''", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'\"evmasm\"'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'case'", "<INVALID>", 
                     "'default'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'leave'", "'let'", "'switch'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "':='" ]

    symbolicNames = [ "<INVALID>", "ReservedKeywords", "Abstract", "Address", 
                      "Anonymous", "As", "Assembly", "Bool", "Break", "Bytes", 
                      "Calldata", "Catch", "Constant", "Constructor", "Continue", 
                      "Contract", "Delete", "Do", "Else", "Emit", "Enum", 
                      "Error", "Event", "External", "Fallback", "False_", 
                      "Fixed", "FixedBytes", "For", "From", "Function", 
                      "Global", "Hex", "If", "Immutable", "Import", "Indexed", 
                      "Interface", "Internal", "Is", "Library", "Mapping", 
                      "Memory", "Modifier", "New", "SubDenomination", "Override", 
                      "Payable", "Pragma", "Private", "Public", "Pure", 
                      "Receive", "Return", "Returns", "Revert", "SignedIntegerType", 
                      "Storage", "String", "Struct", "True_", "Try", "Type", 
                      "Ufixed", "Unchecked", "Unicode", "UnsignedIntegerType", 
                      "Using", "View", "Virtual", "While", "LParen", "RParen", 
                      "LBrack", "RBrack", "LBrace", "RBrace", "Colon", "Semicolon", 
                      "Period", "Conditional", "DoubleArrow", "RightArrow", 
                      "Assign", "AssignBitOr", "AssignBitXor", "AssignBitAnd", 
                      "AssignShl", "AssignSar", "AssignShr", "AssignAdd", 
                      "AssignSub", "AssignMul", "AssignDiv", "AssignMod", 
                      "Comma", "Or", "And", "BitOr", "BitXor", "BitAnd", 
                      "Shl", "Sar", "Shr", "Add", "Sub", "Mul", "Div", "Mod", 
                      "Exp", "Equal", "NotEqual", "LessThan", "GreaterThan", 
                      "LessThanOrEqual", "GreaterThanOrEqual", "Not", "BitNot", 
                      "Inc", "Dec", "DoubleQuote", "SingleQuote", "NonEmptyStringLiteral", 
                      "EmptyStringLiteral", "UnicodeStringLiteral", "HexString", 
                      "HexNumber", "OctalNumber", "DecimalNumber", "DecimalNumberFollowedByIdentifier", 
                      "Identifier", "WS", "COMMENT", "LINE_COMMENT", "AssemblyDialect", 
                      "AssemblyLBrace", "AssemblyFlagString", "AssemblyBlockLParen", 
                      "AssemblyBlockRParen", "AssemblyBlockComma", "AssemblyBlockWS", 
                      "AssemblyBlockCOMMENT", "AssemblyBlockLINE_COMMENT", 
                      "YulBreak", "YulCase", "YulContinue", "YulDefault", 
                      "YulFalse", "YulFor", "YulFunction", "YulIf", "YulLeave", 
                      "YulLet", "YulSwitch", "YulTrue", "YulHex", "YulEVMBuiltin", 
                      "YulLBrace", "YulRBrace", "YulLParen", "YulRParen", 
                      "YulAssign", "YulPeriod", "YulComma", "YulArrow", 
                      "YulIdentifier", "YulHexNumber", "YulDecimalNumber", 
                      "YulStringLiteral", "YulHexStringLiteral", "YulWS", 
                      "YulCOMMENT", "YulLINE_COMMENT", "PragmaToken", "PragmaSemicolon", 
                      "PragmaWS", "PragmaCOMMENT", "PragmaLINE_COMMENT" ]

    RULE_sourceUnit = 0
    RULE_pragmaDirective = 1
    RULE_importDirective = 2
    RULE_importAliases = 3
    RULE_path = 4
    RULE_symbolAliases = 5
    RULE_contractDefinition = 6
    RULE_interfaceDefinition = 7
    RULE_libraryDefinition = 8
    RULE_inheritanceSpecifierList = 9
    RULE_inheritanceSpecifier = 10
    RULE_contractBodyElement = 11
    RULE_namedArgument = 12
    RULE_callArgumentList = 13
    RULE_identifierPath = 14
    RULE_modifierInvocation = 15
    RULE_visibility = 16
    RULE_parameterList = 17
    RULE_parameterDeclaration = 18
    RULE_constructorDefinition = 19
    RULE_stateMutability = 20
    RULE_overrideSpecifier = 21
    RULE_functionDefinition = 22
    RULE_modifierDefinition = 23
    RULE_fallbackFunctionDefinition = 24
    RULE_receiveFunctionDefinition = 25
    RULE_structDefinition = 26
    RULE_structMember = 27
    RULE_enumDefinition = 28
    RULE_userDefinedValueTypeDefinition = 29
    RULE_stateVariableDeclaration = 30
    RULE_constantVariableDeclaration = 31
    RULE_eventParameter = 32
    RULE_eventDefinition = 33
    RULE_errorParameter = 34
    RULE_errorDefinition = 35
    RULE_userDefinableOperator = 36
    RULE_usingDirective = 37
    RULE_usingAliases = 38
    RULE_typeName = 39
    RULE_elementaryTypeName = 40
    RULE_functionTypeName = 41
    RULE_variableDeclaration = 42
    RULE_dataLocation = 43
    RULE_expression = 44
    RULE_assignOp = 45
    RULE_tupleExpression = 46
    RULE_inlineArrayExpression = 47
    RULE_identifier = 48
    RULE_literal = 49
    RULE_literalWithSubDenomination = 50
    RULE_booleanLiteral = 51
    RULE_stringLiteral = 52
    RULE_hexStringLiteral = 53
    RULE_unicodeStringLiteral = 54
    RULE_numberLiteral = 55
    RULE_block = 56
    RULE_uncheckedBlock = 57
    RULE_statement = 58
    RULE_simpleStatement = 59
    RULE_ifStatement = 60
    RULE_forStatement = 61
    RULE_whileStatement = 62
    RULE_doWhileStatement = 63
    RULE_continueStatement = 64
    RULE_breakStatement = 65
    RULE_tryStatement = 66
    RULE_catchClause = 67
    RULE_returnStatement = 68
    RULE_emitStatement = 69
    RULE_revertStatement = 70
    RULE_assemblyStatement = 71
    RULE_assemblyFlags = 72
    RULE_variableDeclarationList = 73
    RULE_variableDeclarationTuple = 74
    RULE_variableDeclarationStatement = 75
    RULE_expressionStatement = 76
    RULE_mappingType = 77
    RULE_mappingKeyType = 78
    RULE_yulStatement = 79
    RULE_yulBlock = 80
    RULE_yulVariableDeclaration = 81
    RULE_yulAssignment = 82
    RULE_yulIfStatement = 83
    RULE_yulForStatement = 84
    RULE_yulSwitchCase = 85
    RULE_yulSwitchStatement = 86
    RULE_yulFunctionDefinition = 87
    RULE_yulPath = 88
    RULE_yulFunctionCall = 89
    RULE_yulBoolean = 90
    RULE_yulLiteral = 91
    RULE_yulExpression = 92

    ruleNames =  [ "sourceUnit", "pragmaDirective", "importDirective", "importAliases", 
                   "path", "symbolAliases", "contractDefinition", "interfaceDefinition", 
                   "libraryDefinition", "inheritanceSpecifierList", "inheritanceSpecifier", 
                   "contractBodyElement", "namedArgument", "callArgumentList", 
                   "identifierPath", "modifierInvocation", "visibility", 
                   "parameterList", "parameterDeclaration", "constructorDefinition", 
                   "stateMutability", "overrideSpecifier", "functionDefinition", 
                   "modifierDefinition", "fallbackFunctionDefinition", "receiveFunctionDefinition", 
                   "structDefinition", "structMember", "enumDefinition", 
                   "userDefinedValueTypeDefinition", "stateVariableDeclaration", 
                   "constantVariableDeclaration", "eventParameter", "eventDefinition", 
                   "errorParameter", "errorDefinition", "userDefinableOperator", 
                   "usingDirective", "usingAliases", "typeName", "elementaryTypeName", 
                   "functionTypeName", "variableDeclaration", "dataLocation", 
                   "expression", "assignOp", "tupleExpression", "inlineArrayExpression", 
                   "identifier", "literal", "literalWithSubDenomination", 
                   "booleanLiteral", "stringLiteral", "hexStringLiteral", 
                   "unicodeStringLiteral", "numberLiteral", "block", "uncheckedBlock", 
                   "statement", "simpleStatement", "ifStatement", "forStatement", 
                   "whileStatement", "doWhileStatement", "continueStatement", 
                   "breakStatement", "tryStatement", "catchClause", "returnStatement", 
                   "emitStatement", "revertStatement", "assemblyStatement", 
                   "assemblyFlags", "variableDeclarationList", "variableDeclarationTuple", 
                   "variableDeclarationStatement", "expressionStatement", 
                   "mappingType", "mappingKeyType", "yulStatement", "yulBlock", 
                   "yulVariableDeclaration", "yulAssignment", "yulIfStatement", 
                   "yulForStatement", "yulSwitchCase", "yulSwitchStatement", 
                   "yulFunctionDefinition", "yulPath", "yulFunctionCall", 
                   "yulBoolean", "yulLiteral", "yulExpression" ]

    EOF = Token.EOF
    ReservedKeywords=1
    Abstract=2
    Address=3
    Anonymous=4
    As=5
    Assembly=6
    Bool=7
    Break=8
    Bytes=9
    Calldata=10
    Catch=11
    Constant=12
    Constructor=13
    Continue=14
    Contract=15
    Delete=16
    Do=17
    Else=18
    Emit=19
    Enum=20
    Error=21
    Event=22
    External=23
    Fallback=24
    False_=25
    Fixed=26
    FixedBytes=27
    For=28
    From=29
    Function=30
    Global=31
    Hex=32
    If=33
    Immutable=34
    Import=35
    Indexed=36
    Interface=37
    Internal=38
    Is=39
    Library=40
    Mapping=41
    Memory=42
    Modifier=43
    New=44
    SubDenomination=45
    Override=46
    Payable=47
    Pragma=48
    Private=49
    Public=50
    Pure=51
    Receive=52
    Return=53
    Returns=54
    Revert=55
    SignedIntegerType=56
    Storage=57
    String=58
    Struct=59
    True_=60
    Try=61
    Type=62
    Ufixed=63
    Unchecked=64
    Unicode=65
    UnsignedIntegerType=66
    Using=67
    View=68
    Virtual=69
    While=70
    LParen=71
    RParen=72
    LBrack=73
    RBrack=74
    LBrace=75
    RBrace=76
    Colon=77
    Semicolon=78
    Period=79
    Conditional=80
    DoubleArrow=81
    RightArrow=82
    Assign=83
    AssignBitOr=84
    AssignBitXor=85
    AssignBitAnd=86
    AssignShl=87
    AssignSar=88
    AssignShr=89
    AssignAdd=90
    AssignSub=91
    AssignMul=92
    AssignDiv=93
    AssignMod=94
    Comma=95
    Or=96
    And=97
    BitOr=98
    BitXor=99
    BitAnd=100
    Shl=101
    Sar=102
    Shr=103
    Add=104
    Sub=105
    Mul=106
    Div=107
    Mod=108
    Exp=109
    Equal=110
    NotEqual=111
    LessThan=112
    GreaterThan=113
    LessThanOrEqual=114
    GreaterThanOrEqual=115
    Not=116
    BitNot=117
    Inc=118
    Dec=119
    DoubleQuote=120
    SingleQuote=121
    NonEmptyStringLiteral=122
    EmptyStringLiteral=123
    UnicodeStringLiteral=124
    HexString=125
    HexNumber=126
    OctalNumber=127
    DecimalNumber=128
    DecimalNumberFollowedByIdentifier=129
    Identifier=130
    WS=131
    COMMENT=132
    LINE_COMMENT=133
    AssemblyDialect=134
    AssemblyLBrace=135
    AssemblyFlagString=136
    AssemblyBlockLParen=137
    AssemblyBlockRParen=138
    AssemblyBlockComma=139
    AssemblyBlockWS=140
    AssemblyBlockCOMMENT=141
    AssemblyBlockLINE_COMMENT=142
    YulBreak=143
    YulCase=144
    YulContinue=145
    YulDefault=146
    YulFalse=147
    YulFor=148
    YulFunction=149
    YulIf=150
    YulLeave=151
    YulLet=152
    YulSwitch=153
    YulTrue=154
    YulHex=155
    YulEVMBuiltin=156
    YulLBrace=157
    YulRBrace=158
    YulLParen=159
    YulRParen=160
    YulAssign=161
    YulPeriod=162
    YulComma=163
    YulArrow=164
    YulIdentifier=165
    YulHexNumber=166
    YulDecimalNumber=167
    YulStringLiteral=168
    YulHexStringLiteral=169
    YulWS=170
    YulCOMMENT=171
    YulLINE_COMMENT=172
    PragmaToken=173
    PragmaSemicolon=174
    PragmaWS=175
    PragmaCOMMENT=176
    PragmaLINE_COMMENT=177

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class SourceUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SolidityParser.EOF, 0)

        def pragmaDirective(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.PragmaDirectiveContext)
            else:
                return self.getTypedRuleContext(SolidityParser.PragmaDirectiveContext,i)


        def importDirective(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ImportDirectiveContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ImportDirectiveContext,i)


        def usingDirective(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.UsingDirectiveContext)
            else:
                return self.getTypedRuleContext(SolidityParser.UsingDirectiveContext,i)


        def contractDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ContractDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ContractDefinitionContext,i)


        def interfaceDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.InterfaceDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.InterfaceDefinitionContext,i)


        def libraryDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.LibraryDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.LibraryDefinitionContext,i)


        def functionDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.FunctionDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.FunctionDefinitionContext,i)


        def constantVariableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ConstantVariableDeclarationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ConstantVariableDeclarationContext,i)


        def structDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StructDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StructDefinitionContext,i)


        def enumDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.EnumDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.EnumDefinitionContext,i)


        def userDefinedValueTypeDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.UserDefinedValueTypeDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.UserDefinedValueTypeDefinitionContext,i)


        def errorDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ErrorDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ErrorDefinitionContext,i)


        def eventDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.EventDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.EventDefinitionContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_sourceUnit

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceUnit" ):
                return visitor.visitSourceUnit(self)
            else:
                return visitor.visitChildren(self)




    def sourceUnit(self):

        localctx = SolidityParser.SourceUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_sourceUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -3638623549638278516) != 0) or _la==66 or _la==67 or _la==130:
                self.state = 199
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                if la_ == 1:
                    self.state = 186
                    self.pragmaDirective()
                    pass

                elif la_ == 2:
                    self.state = 187
                    self.importDirective()
                    pass

                elif la_ == 3:
                    self.state = 188
                    self.usingDirective()
                    pass

                elif la_ == 4:
                    self.state = 189
                    self.contractDefinition()
                    pass

                elif la_ == 5:
                    self.state = 190
                    self.interfaceDefinition()
                    pass

                elif la_ == 6:
                    self.state = 191
                    self.libraryDefinition()
                    pass

                elif la_ == 7:
                    self.state = 192
                    self.functionDefinition()
                    pass

                elif la_ == 8:
                    self.state = 193
                    self.constantVariableDeclaration()
                    pass

                elif la_ == 9:
                    self.state = 194
                    self.structDefinition()
                    pass

                elif la_ == 10:
                    self.state = 195
                    self.enumDefinition()
                    pass

                elif la_ == 11:
                    self.state = 196
                    self.userDefinedValueTypeDefinition()
                    pass

                elif la_ == 12:
                    self.state = 197
                    self.errorDefinition()
                    pass

                elif la_ == 13:
                    self.state = 198
                    self.eventDefinition()
                    pass


                self.state = 203
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 204
            self.match(SolidityParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PragmaDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Pragma(self):
            return self.getToken(SolidityParser.Pragma, 0)

        def PragmaSemicolon(self):
            return self.getToken(SolidityParser.PragmaSemicolon, 0)

        def PragmaToken(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.PragmaToken)
            else:
                return self.getToken(SolidityParser.PragmaToken, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_pragmaDirective

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragmaDirective" ):
                return visitor.visitPragmaDirective(self)
            else:
                return visitor.visitChildren(self)




    def pragmaDirective(self):

        localctx = SolidityParser.PragmaDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_pragmaDirective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.match(SolidityParser.Pragma)
            self.state = 208 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 207
                self.match(SolidityParser.PragmaToken)
                self.state = 210 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==173):
                    break

            self.state = 212
            self.match(SolidityParser.PragmaSemicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitAlias = None # IdentifierContext

        def Import(self):
            return self.getToken(SolidityParser.Import, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def path(self):
            return self.getTypedRuleContext(SolidityParser.PathContext,0)


        def symbolAliases(self):
            return self.getTypedRuleContext(SolidityParser.SymbolAliasesContext,0)


        def From(self):
            return self.getToken(SolidityParser.From, 0)

        def Mul(self):
            return self.getToken(SolidityParser.Mul, 0)

        def As(self):
            return self.getToken(SolidityParser.As, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_importDirective

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportDirective" ):
                return visitor.visitImportDirective(self)
            else:
                return visitor.visitChildren(self)




    def importDirective(self):

        localctx = SolidityParser.ImportDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_importDirective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(SolidityParser.Import)
            self.state = 230
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [122]:
                self.state = 215
                self.path()
                self.state = 218
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==5:
                    self.state = 216
                    self.match(SolidityParser.As)
                    self.state = 217
                    localctx.unitAlias = self.identifier()


                pass
            elif token in [75]:
                self.state = 220
                self.symbolAliases()
                self.state = 221
                self.match(SolidityParser.From)
                self.state = 222
                self.path()
                pass
            elif token in [106]:
                self.state = 224
                self.match(SolidityParser.Mul)
                self.state = 225
                self.match(SolidityParser.As)
                self.state = 226
                localctx.unitAlias = self.identifier()
                self.state = 227
                self.match(SolidityParser.From)
                self.state = 228
                self.path()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 232
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportAliasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.symbol = None # IdentifierContext
            self.alias = None # IdentifierContext

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierContext,i)


        def As(self):
            return self.getToken(SolidityParser.As, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_importAliases

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportAliases" ):
                return visitor.visitImportAliases(self)
            else:
                return visitor.visitChildren(self)




    def importAliases(self):

        localctx = SolidityParser.ImportAliasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_importAliases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            localctx.symbol = self.identifier()
            self.state = 237
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5:
                self.state = 235
                self.match(SolidityParser.As)
                self.state = 236
                localctx.alias = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NonEmptyStringLiteral(self):
            return self.getToken(SolidityParser.NonEmptyStringLiteral, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_path

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPath" ):
                return visitor.visitPath(self)
            else:
                return visitor.visitChildren(self)




    def path(self):

        localctx = SolidityParser.PathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_path)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self.match(SolidityParser.NonEmptyStringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymbolAliasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._importAliases = None # ImportAliasesContext
            self.aliases = list() # of ImportAliasesContexts

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def importAliases(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ImportAliasesContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ImportAliasesContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_symbolAliases

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbolAliases" ):
                return visitor.visitSymbolAliases(self)
            else:
                return visitor.visitChildren(self)




    def symbolAliases(self):

        localctx = SolidityParser.SymbolAliasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_symbolAliases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.match(SolidityParser.LBrace)
            self.state = 242
            localctx._importAliases = self.importAliases()
            localctx.aliases.append(localctx._importAliases)
            self.state = 247
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==95:
                self.state = 243
                self.match(SolidityParser.Comma)
                self.state = 244
                localctx._importAliases = self.importAliases()
                localctx.aliases.append(localctx._importAliases)
                self.state = 249
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 250
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContractDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def Contract(self):
            return self.getToken(SolidityParser.Contract, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def Abstract(self):
            return self.getToken(SolidityParser.Abstract, 0)

        def inheritanceSpecifierList(self):
            return self.getTypedRuleContext(SolidityParser.InheritanceSpecifierListContext,0)


        def contractBodyElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ContractBodyElementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ContractBodyElementContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_contractDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContractDefinition" ):
                return visitor.visitContractDefinition(self)
            else:
                return visitor.visitChildren(self)




    def contractDefinition(self):

        localctx = SolidityParser.ContractDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_contractDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==2:
                self.state = 252
                self.match(SolidityParser.Abstract)


            self.state = 255
            self.match(SolidityParser.Contract)
            self.state = 256
            localctx.name = self.identifier()
            self.state = 258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 257
                self.inheritanceSpecifierList()


            self.state = 260
            self.match(SolidityParser.LBrace)
            self.state = 264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7371828265164602287) != 0) or _la==67 or _la==130:
                self.state = 261
                self.contractBodyElement()
                self.state = 266
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 267
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfaceDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def Interface(self):
            return self.getToken(SolidityParser.Interface, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def inheritanceSpecifierList(self):
            return self.getTypedRuleContext(SolidityParser.InheritanceSpecifierListContext,0)


        def contractBodyElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ContractBodyElementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ContractBodyElementContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_interfaceDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfaceDefinition" ):
                return visitor.visitInterfaceDefinition(self)
            else:
                return visitor.visitChildren(self)




    def interfaceDefinition(self):

        localctx = SolidityParser.InterfaceDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_interfaceDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self.match(SolidityParser.Interface)
            self.state = 270
            localctx.name = self.identifier()
            self.state = 272
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 271
                self.inheritanceSpecifierList()


            self.state = 274
            self.match(SolidityParser.LBrace)
            self.state = 278
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7371828265164602287) != 0) or _la==67 or _la==130:
                self.state = 275
                self.contractBodyElement()
                self.state = 280
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 281
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LibraryDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def Library(self):
            return self.getToken(SolidityParser.Library, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def contractBodyElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ContractBodyElementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ContractBodyElementContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_libraryDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLibraryDefinition" ):
                return visitor.visitLibraryDefinition(self)
            else:
                return visitor.visitChildren(self)




    def libraryDefinition(self):

        localctx = SolidityParser.LibraryDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_libraryDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.match(SolidityParser.Library)
            self.state = 284
            localctx.name = self.identifier()
            self.state = 285
            self.match(SolidityParser.LBrace)
            self.state = 289
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7371828265164602287) != 0) or _la==67 or _la==130:
                self.state = 286
                self.contractBodyElement()
                self.state = 291
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 292
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InheritanceSpecifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._inheritanceSpecifier = None # InheritanceSpecifierContext
            self.inheritanceSpecifiers = list() # of InheritanceSpecifierContexts

        def Is(self):
            return self.getToken(SolidityParser.Is, 0)

        def inheritanceSpecifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.InheritanceSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.InheritanceSpecifierContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_inheritanceSpecifierList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInheritanceSpecifierList" ):
                return visitor.visitInheritanceSpecifierList(self)
            else:
                return visitor.visitChildren(self)




    def inheritanceSpecifierList(self):

        localctx = SolidityParser.InheritanceSpecifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_inheritanceSpecifierList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.match(SolidityParser.Is)
            self.state = 295
            localctx._inheritanceSpecifier = self.inheritanceSpecifier()
            localctx.inheritanceSpecifiers.append(localctx._inheritanceSpecifier)
            self.state = 300
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 296
                    self.match(SolidityParser.Comma)
                    self.state = 297
                    localctx._inheritanceSpecifier = self.inheritanceSpecifier()
                    localctx.inheritanceSpecifiers.append(localctx._inheritanceSpecifier) 
                self.state = 302
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InheritanceSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierPathContext
            self.arguments = None # CallArgumentListContext

        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext,0)


        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_inheritanceSpecifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInheritanceSpecifier" ):
                return visitor.visitInheritanceSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def inheritanceSpecifier(self):

        localctx = SolidityParser.InheritanceSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_inheritanceSpecifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            localctx.name = self.identifierPath()
            self.state = 305
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 304
                localctx.arguments = self.callArgumentList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContractBodyElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constructorDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ConstructorDefinitionContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(SolidityParser.FunctionDefinitionContext,0)


        def modifierDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ModifierDefinitionContext,0)


        def fallbackFunctionDefinition(self):
            return self.getTypedRuleContext(SolidityParser.FallbackFunctionDefinitionContext,0)


        def receiveFunctionDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ReceiveFunctionDefinitionContext,0)


        def structDefinition(self):
            return self.getTypedRuleContext(SolidityParser.StructDefinitionContext,0)


        def enumDefinition(self):
            return self.getTypedRuleContext(SolidityParser.EnumDefinitionContext,0)


        def userDefinedValueTypeDefinition(self):
            return self.getTypedRuleContext(SolidityParser.UserDefinedValueTypeDefinitionContext,0)


        def stateVariableDeclaration(self):
            return self.getTypedRuleContext(SolidityParser.StateVariableDeclarationContext,0)


        def eventDefinition(self):
            return self.getTypedRuleContext(SolidityParser.EventDefinitionContext,0)


        def errorDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ErrorDefinitionContext,0)


        def usingDirective(self):
            return self.getTypedRuleContext(SolidityParser.UsingDirectiveContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_contractBodyElement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContractBodyElement" ):
                return visitor.visitContractBodyElement(self)
            else:
                return visitor.visitChildren(self)




    def contractBodyElement(self):

        localctx = SolidityParser.ContractBodyElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_contractBodyElement)
        try:
            self.state = 319
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 307
                self.constructorDefinition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 308
                self.functionDefinition()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 309
                self.modifierDefinition()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 310
                self.fallbackFunctionDefinition()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 311
                self.receiveFunctionDefinition()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 312
                self.structDefinition()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 313
                self.enumDefinition()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 314
                self.userDefinedValueTypeDefinition()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 315
                self.stateVariableDeclaration()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 316
                self.eventDefinition()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 317
                self.errorDefinition()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 318
                self.usingDirective()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.value = None # ExpressionContext

        def Colon(self):
            return self.getToken(SolidityParser.Colon, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_namedArgument

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedArgument" ):
                return visitor.visitNamedArgument(self)
            else:
                return visitor.visitChildren(self)




    def namedArgument(self):

        localctx = SolidityParser.NamedArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_namedArgument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 321
            localctx.name = self.identifier()
            self.state = 322
            self.match(SolidityParser.Colon)
            self.state = 323
            localctx.value = self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)


        def namedArgument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.NamedArgumentContext)
            else:
                return self.getTypedRuleContext(SolidityParser.NamedArgumentContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_callArgumentList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallArgumentList" ):
                return visitor.visitCallArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def callArgumentList(self):

        localctx = SolidityParser.CallArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_callArgumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self.match(SolidityParser.LParen)
            self.state = 348
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 7, 9, 16, 21, 25, 26, 27, 29, 31, 44, 47, 55, 56, 58, 60, 62, 63, 66, 71, 72, 73, 105, 116, 117, 118, 119, 122, 123, 124, 125, 126, 128, 130]:
                self.state = 334
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                    self.state = 326
                    self.expression(0)
                    self.state = 331
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==95:
                        self.state = 327
                        self.match(SolidityParser.Comma)
                        self.state = 328
                        self.expression(0)
                        self.state = 333
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                pass
            elif token in [75]:
                self.state = 336
                self.match(SolidityParser.LBrace)
                self.state = 345
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130:
                    self.state = 337
                    self.namedArgument()
                    self.state = 342
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==95:
                        self.state = 338
                        self.match(SolidityParser.Comma)
                        self.state = 339
                        self.namedArgument()
                        self.state = 344
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 347
                self.match(SolidityParser.RBrace)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 350
            self.match(SolidityParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierPathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierContext,i)


        def Period(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Period)
            else:
                return self.getToken(SolidityParser.Period, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_identifierPath

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierPath" ):
                return visitor.visitIdentifierPath(self)
            else:
                return visitor.visitChildren(self)




    def identifierPath(self):

        localctx = SolidityParser.IdentifierPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_identifierPath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self.identifier()
            self.state = 357
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,21,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 353
                    self.match(SolidityParser.Period)
                    self.state = 354
                    self.identifier() 
                self.state = 359
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierInvocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext,0)


        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_modifierInvocation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifierInvocation" ):
                return visitor.visitModifierInvocation(self)
            else:
                return visitor.visitChildren(self)




    def modifierInvocation(self):

        localctx = SolidityParser.ModifierInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_modifierInvocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.identifierPath()
            self.state = 362
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 361
                self.callArgumentList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Internal(self):
            return self.getToken(SolidityParser.Internal, 0)

        def External(self):
            return self.getToken(SolidityParser.External, 0)

        def Private(self):
            return self.getToken(SolidityParser.Private, 0)

        def Public(self):
            return self.getToken(SolidityParser.Public, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_visibility

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibility" ):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)




    def visibility(self):

        localctx = SolidityParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_visibility)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 364
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1689124746559488) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._parameterDeclaration = None # ParameterDeclarationContext
            self.parameters = list() # of ParameterDeclarationContexts

        def parameterDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterDeclarationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterDeclarationContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_parameterList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterList" ):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)




    def parameterList(self):

        localctx = SolidityParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 366
            localctx._parameterDeclaration = self.parameterDeclaration()
            localctx.parameters.append(localctx._parameterDeclaration)
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==95:
                self.state = 367
                self.match(SolidityParser.Comma)
                self.state = 368
                localctx._parameterDeclaration = self.parameterDeclaration()
                localctx.parameters.append(localctx._parameterDeclaration)
                self.state = 373
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # TypeNameContext
            self.location = None # DataLocationContext
            self.name = None # IdentifierContext

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def dataLocation(self):
            return self.getTypedRuleContext(SolidityParser.DataLocationContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_parameterDeclaration

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDeclaration" ):
                return visitor.visitParameterDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def parameterDeclaration(self):

        localctx = SolidityParser.ParameterDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_parameterDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 374
            localctx.type_ = self.typeName(0)
            self.state = 376
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 144119586122368000) != 0):
                self.state = 375
                localctx.location = self.dataLocation()


            self.state = 379
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130:
                self.state = 378
                localctx.name = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructorDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.arguments = None # ParameterListContext
            self.body = None # BlockContext

        def Constructor(self):
            return self.getToken(SolidityParser.Constructor, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def modifierInvocation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ModifierInvocationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ModifierInvocationContext,i)


        def Payable(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Payable)
            else:
                return self.getToken(SolidityParser.Payable, i)

        def Internal(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Internal)
            else:
                return self.getToken(SolidityParser.Internal, i)

        def Public(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Public)
            else:
                return self.getToken(SolidityParser.Public, i)

        def parameterList(self):
            return self.getTypedRuleContext(SolidityParser.ParameterListContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_constructorDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstructorDefinition" ):
                return visitor.visitConstructorDefinition(self)
            else:
                return visitor.visitChildren(self)




    def constructorDefinition(self):

        localctx = SolidityParser.ConstructorDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_constructorDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            self.match(SolidityParser.Constructor)
            self.state = 382
            self.match(SolidityParser.LParen)
            self.state = 384
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130:
                self.state = 383
                localctx.arguments = self.parameterList()


            self.state = 386
            self.match(SolidityParser.RParen)
            self.state = 393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 37295711978520576) != 0) or _la==130:
                self.state = 391
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [21, 29, 31, 55, 130]:
                    self.state = 387
                    self.modifierInvocation()
                    pass
                elif token in [47]:
                    self.state = 388
                    self.match(SolidityParser.Payable)
                    pass
                elif token in [38]:
                    self.state = 389
                    self.match(SolidityParser.Internal)
                    pass
                elif token in [50]:
                    self.state = 390
                    self.match(SolidityParser.Public)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 395
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 396
            localctx.body = self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StateMutabilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Pure(self):
            return self.getToken(SolidityParser.Pure, 0)

        def View(self):
            return self.getToken(SolidityParser.View, 0)

        def Payable(self):
            return self.getToken(SolidityParser.Payable, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_stateMutability

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStateMutability" ):
                return visitor.visitStateMutability(self)
            else:
                return visitor.visitChildren(self)




    def stateMutability(self):

        localctx = SolidityParser.StateMutabilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_stateMutability)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            _la = self._input.LA(1)
            if not(((((_la - 47)) & ~0x3f) == 0 and ((1 << (_la - 47)) & 2097169) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OverrideSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._identifierPath = None # IdentifierPathContext
            self.overrides = list() # of IdentifierPathContexts

        def Override(self):
            return self.getToken(SolidityParser.Override, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def identifierPath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierPathContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierPathContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_overrideSpecifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOverrideSpecifier" ):
                return visitor.visitOverrideSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def overrideSpecifier(self):

        localctx = SolidityParser.OverrideSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_overrideSpecifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 400
            self.match(SolidityParser.Override)
            self.state = 412
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 401
                self.match(SolidityParser.LParen)
                self.state = 402
                localctx._identifierPath = self.identifierPath()
                localctx.overrides.append(localctx._identifierPath)
                self.state = 407
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==95:
                    self.state = 403
                    self.match(SolidityParser.Comma)
                    self.state = 404
                    localctx._identifierPath = self.identifierPath()
                    localctx.overrides.append(localctx._identifierPath)
                    self.state = 409
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 410
                self.match(SolidityParser.RParen)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.arguments = None # ParameterListContext
            self.returnParameters = None # ParameterListContext
            self.body = None # BlockContext

        def Function(self):
            return self.getToken(SolidityParser.Function, 0)

        def LParen(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.LParen)
            else:
                return self.getToken(SolidityParser.LParen, i)

        def RParen(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.RParen)
            else:
                return self.getToken(SolidityParser.RParen, i)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def Fallback(self):
            return self.getToken(SolidityParser.Fallback, 0)

        def Receive(self):
            return self.getToken(SolidityParser.Receive, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def visibility(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.VisibilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.VisibilityContext,i)


        def stateMutability(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StateMutabilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StateMutabilityContext,i)


        def modifierInvocation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ModifierInvocationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ModifierInvocationContext,i)


        def Virtual(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Virtual)
            else:
                return self.getToken(SolidityParser.Virtual, i)

        def overrideSpecifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext,i)


        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def parameterList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterListContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterListContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_functionDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDefinition" ):
                return visitor.visitFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def functionDefinition(self):

        localctx = SolidityParser.FunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_functionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 414
            self.match(SolidityParser.Function)
            self.state = 418
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 29, 31, 55, 130]:
                self.state = 415
                self.identifier()
                pass
            elif token in [24]:
                self.state = 416
                self.match(SolidityParser.Fallback)
                pass
            elif token in [52]:
                self.state = 417
                self.match(SolidityParser.Receive)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 420
            self.match(SolidityParser.LParen)
            self.state = 422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130:
                self.state = 421
                localctx.arguments = self.parameterList()


            self.state = 424
            self.match(SolidityParser.RParen)
            self.state = 432
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 40180830498193408) != 0) or ((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 4611686018427387907) != 0):
                self.state = 430
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23, 38, 49, 50]:
                    self.state = 425
                    self.visibility()
                    pass
                elif token in [47, 51, 68]:
                    self.state = 426
                    self.stateMutability()
                    pass
                elif token in [21, 29, 31, 55, 130]:
                    self.state = 427
                    self.modifierInvocation()
                    pass
                elif token in [69]:
                    self.state = 428
                    self.match(SolidityParser.Virtual)
                    pass
                elif token in [46]:
                    self.state = 429
                    self.overrideSpecifier()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 434
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 440
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 435
                self.match(SolidityParser.Returns)
                self.state = 436
                self.match(SolidityParser.LParen)
                self.state = 437
                localctx.returnParameters = self.parameterList()
                self.state = 438
                self.match(SolidityParser.RParen)


            self.state = 444
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 442
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 443
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.arguments = None # ParameterListContext
            self.body = None # BlockContext

        def Modifier(self):
            return self.getToken(SolidityParser.Modifier, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Virtual(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Virtual)
            else:
                return self.getToken(SolidityParser.Virtual, i)

        def overrideSpecifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext,i)


        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def parameterList(self):
            return self.getTypedRuleContext(SolidityParser.ParameterListContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_modifierDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifierDefinition" ):
                return visitor.visitModifierDefinition(self)
            else:
                return visitor.visitChildren(self)




    def modifierDefinition(self):

        localctx = SolidityParser.ModifierDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_modifierDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 446
            self.match(SolidityParser.Modifier)
            self.state = 447
            localctx.name = self.identifier()
            self.state = 453
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 448
                self.match(SolidityParser.LParen)
                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130:
                    self.state = 449
                    localctx.arguments = self.parameterList()


                self.state = 452
                self.match(SolidityParser.RParen)


            self.state = 459
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46 or _la==69:
                self.state = 457
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [69]:
                    self.state = 455
                    self.match(SolidityParser.Virtual)
                    pass
                elif token in [46]:
                    self.state = 456
                    self.overrideSpecifier()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 461
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 464
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 462
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 463
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FallbackFunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.kind = None # Token
            self.returnParameters = None # ParameterListContext
            self.body = None # BlockContext

        def LParen(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.LParen)
            else:
                return self.getToken(SolidityParser.LParen, i)

        def RParen(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.RParen)
            else:
                return self.getToken(SolidityParser.RParen, i)

        def Fallback(self):
            return self.getToken(SolidityParser.Fallback, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def parameterList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterListContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterListContext,i)


        def External(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.External)
            else:
                return self.getToken(SolidityParser.External, i)

        def stateMutability(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StateMutabilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StateMutabilityContext,i)


        def modifierInvocation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ModifierInvocationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ModifierInvocationContext,i)


        def Virtual(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Virtual)
            else:
                return self.getToken(SolidityParser.Virtual, i)

        def overrideSpecifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext,i)


        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_fallbackFunctionDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFallbackFunctionDefinition" ):
                return visitor.visitFallbackFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def fallbackFunctionDefinition(self):

        localctx = SolidityParser.FallbackFunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_fallbackFunctionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 466
            localctx.kind = self.match(SolidityParser.Fallback)
            self.state = 467
            self.match(SolidityParser.LParen)
            self.state = 469
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130:
                self.state = 468
                self.parameterList()


            self.state = 471
            self.match(SolidityParser.RParen)
            self.state = 479
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 38491705760022528) != 0) or ((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 4611686018427387907) != 0):
                self.state = 477
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23]:
                    self.state = 472
                    self.match(SolidityParser.External)
                    pass
                elif token in [47, 51, 68]:
                    self.state = 473
                    self.stateMutability()
                    pass
                elif token in [21, 29, 31, 55, 130]:
                    self.state = 474
                    self.modifierInvocation()
                    pass
                elif token in [69]:
                    self.state = 475
                    self.match(SolidityParser.Virtual)
                    pass
                elif token in [46]:
                    self.state = 476
                    self.overrideSpecifier()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 481
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 487
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 482
                self.match(SolidityParser.Returns)
                self.state = 483
                self.match(SolidityParser.LParen)
                self.state = 484
                localctx.returnParameters = self.parameterList()
                self.state = 485
                self.match(SolidityParser.RParen)


            self.state = 491
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 489
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 490
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReceiveFunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.kind = None # Token
            self.body = None # BlockContext

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Receive(self):
            return self.getToken(SolidityParser.Receive, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def External(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.External)
            else:
                return self.getToken(SolidityParser.External, i)

        def Payable(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Payable)
            else:
                return self.getToken(SolidityParser.Payable, i)

        def modifierInvocation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ModifierInvocationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ModifierInvocationContext,i)


        def Virtual(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Virtual)
            else:
                return self.getToken(SolidityParser.Virtual, i)

        def overrideSpecifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext,i)


        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_receiveFunctionDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReceiveFunctionDefinition" ):
                return visitor.visitReceiveFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def receiveFunctionDefinition(self):

        localctx = SolidityParser.ReceiveFunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_receiveFunctionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            localctx.kind = self.match(SolidityParser.Receive)
            self.state = 494
            self.match(SolidityParser.LParen)
            self.state = 495
            self.match(SolidityParser.RParen)
            self.state = 503
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 36239905946337280) != 0) or _la==69 or _la==130:
                self.state = 501
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23]:
                    self.state = 496
                    self.match(SolidityParser.External)
                    pass
                elif token in [47]:
                    self.state = 497
                    self.match(SolidityParser.Payable)
                    pass
                elif token in [21, 29, 31, 55, 130]:
                    self.state = 498
                    self.modifierInvocation()
                    pass
                elif token in [69]:
                    self.state = 499
                    self.match(SolidityParser.Virtual)
                    pass
                elif token in [46]:
                    self.state = 500
                    self.overrideSpecifier()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 505
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 508
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 506
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 507
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.members = None # StructMemberContext

        def Struct(self):
            return self.getToken(SolidityParser.Struct, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def structMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StructMemberContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StructMemberContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_structDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructDefinition" ):
                return visitor.visitStructDefinition(self)
            else:
                return visitor.visitChildren(self)




    def structDefinition(self):

        localctx = SolidityParser.StructDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_structDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 510
            self.match(SolidityParser.Struct)
            self.state = 511
            localctx.name = self.identifier()
            self.state = 512
            self.match(SolidityParser.LBrace)
            self.state = 514 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 513
                localctx.members = self.structMember()
                self.state = 516 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130):
                    break

            self.state = 518
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # TypeNameContext
            self.name = None # IdentifierContext

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_structMember

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructMember" ):
                return visitor.visitStructMember(self)
            else:
                return visitor.visitChildren(self)




    def structMember(self):

        localctx = SolidityParser.StructMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_structMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 520
            localctx.type_ = self.typeName(0)
            self.state = 521
            localctx.name = self.identifier()
            self.state = 522
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self._identifier = None # IdentifierContext
            self.enumValues = list() # of IdentifierContexts

        def Enum(self):
            return self.getToken(SolidityParser.Enum, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_enumDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumDefinition" ):
                return visitor.visitEnumDefinition(self)
            else:
                return visitor.visitChildren(self)




    def enumDefinition(self):

        localctx = SolidityParser.EnumDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_enumDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 524
            self.match(SolidityParser.Enum)
            self.state = 525
            localctx.name = self.identifier()
            self.state = 526
            self.match(SolidityParser.LBrace)
            self.state = 527
            localctx._identifier = self.identifier()
            localctx.enumValues.append(localctx._identifier)
            self.state = 532
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==95:
                self.state = 528
                self.match(SolidityParser.Comma)
                self.state = 529
                localctx._identifier = self.identifier()
                localctx.enumValues.append(localctx._identifier)
                self.state = 534
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 535
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserDefinedValueTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def Type(self):
            return self.getToken(SolidityParser.Type, 0)

        def Is(self):
            return self.getToken(SolidityParser.Is, 0)

        def elementaryTypeName(self):
            return self.getTypedRuleContext(SolidityParser.ElementaryTypeNameContext,0)


        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_userDefinedValueTypeDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserDefinedValueTypeDefinition" ):
                return visitor.visitUserDefinedValueTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def userDefinedValueTypeDefinition(self):

        localctx = SolidityParser.UserDefinedValueTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_userDefinedValueTypeDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 537
            self.match(SolidityParser.Type)
            self.state = 538
            localctx.name = self.identifier()
            self.state = 539
            self.match(SolidityParser.Is)
            self.state = 540
            self.elementaryTypeName()
            self.state = 541
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StateVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # TypeNameContext
            self.name = None # IdentifierContext
            self.initialValue = None # ExpressionContext

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def Public(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Public)
            else:
                return self.getToken(SolidityParser.Public, i)

        def Private(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Private)
            else:
                return self.getToken(SolidityParser.Private, i)

        def Internal(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Internal)
            else:
                return self.getToken(SolidityParser.Internal, i)

        def Constant(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Constant)
            else:
                return self.getToken(SolidityParser.Constant, i)

        def overrideSpecifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext,i)


        def Immutable(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Immutable)
            else:
                return self.getToken(SolidityParser.Immutable, i)

        def Assign(self):
            return self.getToken(SolidityParser.Assign, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_stateVariableDeclaration

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStateVariableDeclaration" ):
                return visitor.visitStateVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def stateVariableDeclaration(self):

        localctx = SolidityParser.StateVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_stateVariableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            localctx.type_ = self.typeName(0)
            self.state = 552
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 1759510662221824) != 0):
                self.state = 550
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [50]:
                    self.state = 544
                    self.match(SolidityParser.Public)
                    pass
                elif token in [49]:
                    self.state = 545
                    self.match(SolidityParser.Private)
                    pass
                elif token in [38]:
                    self.state = 546
                    self.match(SolidityParser.Internal)
                    pass
                elif token in [12]:
                    self.state = 547
                    self.match(SolidityParser.Constant)
                    pass
                elif token in [46]:
                    self.state = 548
                    self.overrideSpecifier()
                    pass
                elif token in [34]:
                    self.state = 549
                    self.match(SolidityParser.Immutable)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 554
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 555
            localctx.name = self.identifier()
            self.state = 558
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==83:
                self.state = 556
                self.match(SolidityParser.Assign)
                self.state = 557
                localctx.initialValue = self.expression(0)


            self.state = 560
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # TypeNameContext
            self.name = None # IdentifierContext
            self.initialValue = None # ExpressionContext

        def Constant(self):
            return self.getToken(SolidityParser.Constant, 0)

        def Assign(self):
            return self.getToken(SolidityParser.Assign, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_constantVariableDeclaration

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstantVariableDeclaration" ):
                return visitor.visitConstantVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def constantVariableDeclaration(self):

        localctx = SolidityParser.ConstantVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_constantVariableDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 562
            localctx.type_ = self.typeName(0)
            self.state = 563
            self.match(SolidityParser.Constant)
            self.state = 564
            localctx.name = self.identifier()
            self.state = 565
            self.match(SolidityParser.Assign)
            self.state = 566
            localctx.initialValue = self.expression(0)
            self.state = 567
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # TypeNameContext
            self.name = None # IdentifierContext

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def Indexed(self):
            return self.getToken(SolidityParser.Indexed, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_eventParameter

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventParameter" ):
                return visitor.visitEventParameter(self)
            else:
                return visitor.visitChildren(self)




    def eventParameter(self):

        localctx = SolidityParser.EventParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_eventParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 569
            localctx.type_ = self.typeName(0)
            self.state = 571
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==36:
                self.state = 570
                self.match(SolidityParser.Indexed)


            self.state = 574
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130:
                self.state = 573
                localctx.name = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self._eventParameter = None # EventParameterContext
            self.parameters = list() # of EventParameterContexts

        def Event(self):
            return self.getToken(SolidityParser.Event, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def Anonymous(self):
            return self.getToken(SolidityParser.Anonymous, 0)

        def eventParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.EventParameterContext)
            else:
                return self.getTypedRuleContext(SolidityParser.EventParameterContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_eventDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventDefinition" ):
                return visitor.visitEventDefinition(self)
            else:
                return visitor.visitChildren(self)




    def eventDefinition(self):

        localctx = SolidityParser.EventDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_eventDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 576
            self.match(SolidityParser.Event)
            self.state = 577
            localctx.name = self.identifier()
            self.state = 578
            self.match(SolidityParser.LParen)
            self.state = 587
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130:
                self.state = 579
                localctx._eventParameter = self.eventParameter()
                localctx.parameters.append(localctx._eventParameter)
                self.state = 584
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==95:
                    self.state = 580
                    self.match(SolidityParser.Comma)
                    self.state = 581
                    localctx._eventParameter = self.eventParameter()
                    localctx.parameters.append(localctx._eventParameter)
                    self.state = 586
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 589
            self.match(SolidityParser.RParen)
            self.state = 591
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 590
                self.match(SolidityParser.Anonymous)


            self.state = 593
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # TypeNameContext
            self.name = None # IdentifierContext

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_errorParameter

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitErrorParameter" ):
                return visitor.visitErrorParameter(self)
            else:
                return visitor.visitChildren(self)




    def errorParameter(self):

        localctx = SolidityParser.ErrorParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_errorParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 595
            localctx.type_ = self.typeName(0)
            self.state = 597
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130:
                self.state = 596
                localctx.name = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self._errorParameter = None # ErrorParameterContext
            self.parameters = list() # of ErrorParameterContexts

        def Error(self):
            return self.getToken(SolidityParser.Error, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def errorParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ErrorParameterContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ErrorParameterContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_errorDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitErrorDefinition" ):
                return visitor.visitErrorDefinition(self)
            else:
                return visitor.visitChildren(self)




    def errorDefinition(self):

        localctx = SolidityParser.ErrorDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_errorDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 599
            self.match(SolidityParser.Error)
            self.state = 600
            localctx.name = self.identifier()
            self.state = 601
            self.match(SolidityParser.LParen)
            self.state = 610
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130:
                self.state = 602
                localctx._errorParameter = self.errorParameter()
                localctx.parameters.append(localctx._errorParameter)
                self.state = 607
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==95:
                    self.state = 603
                    self.match(SolidityParser.Comma)
                    self.state = 604
                    localctx._errorParameter = self.errorParameter()
                    localctx.parameters.append(localctx._errorParameter)
                    self.state = 609
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 612
            self.match(SolidityParser.RParen)
            self.state = 613
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserDefinableOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BitAnd(self):
            return self.getToken(SolidityParser.BitAnd, 0)

        def BitNot(self):
            return self.getToken(SolidityParser.BitNot, 0)

        def BitOr(self):
            return self.getToken(SolidityParser.BitOr, 0)

        def BitXor(self):
            return self.getToken(SolidityParser.BitXor, 0)

        def Add(self):
            return self.getToken(SolidityParser.Add, 0)

        def Div(self):
            return self.getToken(SolidityParser.Div, 0)

        def Mod(self):
            return self.getToken(SolidityParser.Mod, 0)

        def Mul(self):
            return self.getToken(SolidityParser.Mul, 0)

        def Sub(self):
            return self.getToken(SolidityParser.Sub, 0)

        def Equal(self):
            return self.getToken(SolidityParser.Equal, 0)

        def GreaterThan(self):
            return self.getToken(SolidityParser.GreaterThan, 0)

        def GreaterThanOrEqual(self):
            return self.getToken(SolidityParser.GreaterThanOrEqual, 0)

        def LessThan(self):
            return self.getToken(SolidityParser.LessThan, 0)

        def LessThanOrEqual(self):
            return self.getToken(SolidityParser.LessThanOrEqual, 0)

        def NotEqual(self):
            return self.getToken(SolidityParser.NotEqual, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_userDefinableOperator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserDefinableOperator" ):
                return visitor.visitUserDefinableOperator(self)
            else:
                return visitor.visitChildren(self)




    def userDefinableOperator(self):

        localctx = SolidityParser.UserDefinableOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_userDefinableOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 615
            _la = self._input.LA(1)
            if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 784327) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UsingDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Using(self):
            return self.getToken(SolidityParser.Using, 0)

        def For(self):
            return self.getToken(SolidityParser.For, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext,0)


        def Mul(self):
            return self.getToken(SolidityParser.Mul, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def Global(self):
            return self.getToken(SolidityParser.Global, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def usingAliases(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.UsingAliasesContext)
            else:
                return self.getTypedRuleContext(SolidityParser.UsingAliasesContext,i)


        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_usingDirective

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUsingDirective" ):
                return visitor.visitUsingDirective(self)
            else:
                return visitor.visitChildren(self)




    def usingDirective(self):

        localctx = SolidityParser.UsingDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_usingDirective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 617
            self.match(SolidityParser.Using)
            self.state = 630
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 29, 31, 55, 130]:
                self.state = 618
                self.identifierPath()
                pass
            elif token in [75]:
                self.state = 619
                self.match(SolidityParser.LBrace)
                self.state = 620
                self.usingAliases()
                self.state = 625
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==95:
                    self.state = 621
                    self.match(SolidityParser.Comma)
                    self.state = 622
                    self.usingAliases()
                    self.state = 627
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 628
                self.match(SolidityParser.RBrace)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 632
            self.match(SolidityParser.For)
            self.state = 635
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [106]:
                self.state = 633
                self.match(SolidityParser.Mul)
                pass
            elif token in [3, 7, 9, 21, 26, 27, 29, 30, 31, 41, 55, 56, 58, 63, 66, 130]:
                self.state = 634
                self.typeName(0)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 638
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31:
                self.state = 637
                self.match(SolidityParser.Global)


            self.state = 640
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UsingAliasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext,0)


        def As(self):
            return self.getToken(SolidityParser.As, 0)

        def userDefinableOperator(self):
            return self.getTypedRuleContext(SolidityParser.UserDefinableOperatorContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_usingAliases

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUsingAliases" ):
                return visitor.visitUsingAliases(self)
            else:
                return visitor.visitChildren(self)




    def usingAliases(self):

        localctx = SolidityParser.UsingAliasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_usingAliases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 642
            self.identifierPath()
            self.state = 645
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5:
                self.state = 643
                self.match(SolidityParser.As)
                self.state = 644
                self.userDefinableOperator()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementaryTypeName(self):
            return self.getTypedRuleContext(SolidityParser.ElementaryTypeNameContext,0)


        def functionTypeName(self):
            return self.getTypedRuleContext(SolidityParser.FunctionTypeNameContext,0)


        def mappingType(self):
            return self.getTypedRuleContext(SolidityParser.MappingTypeContext,0)


        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext,0)


        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def LBrack(self):
            return self.getToken(SolidityParser.LBrack, 0)

        def RBrack(self):
            return self.getToken(SolidityParser.RBrack, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_typeName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeName" ):
                return visitor.visitTypeName(self)
            else:
                return visitor.visitChildren(self)



    def typeName(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SolidityParser.TypeNameContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 78
        self.enterRecursionRule(localctx, 78, self.RULE_typeName, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 652
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 7, 9, 26, 27, 56, 58, 63, 66]:
                self.state = 648
                self.elementaryTypeName()
                pass
            elif token in [30]:
                self.state = 649
                self.functionTypeName()
                pass
            elif token in [41]:
                self.state = 650
                self.mappingType()
                pass
            elif token in [21, 29, 31, 55, 130]:
                self.state = 651
                self.identifierPath()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 662
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,70,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = SolidityParser.TypeNameContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_typeName)
                    self.state = 654
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 655
                    self.match(SolidityParser.LBrack)
                    self.state = 657
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                        self.state = 656
                        self.expression(0)


                    self.state = 659
                    self.match(SolidityParser.RBrack) 
                self.state = 664
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,70,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ElementaryTypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Address(self):
            return self.getToken(SolidityParser.Address, 0)

        def Payable(self):
            return self.getToken(SolidityParser.Payable, 0)

        def Bool(self):
            return self.getToken(SolidityParser.Bool, 0)

        def String(self):
            return self.getToken(SolidityParser.String, 0)

        def Bytes(self):
            return self.getToken(SolidityParser.Bytes, 0)

        def SignedIntegerType(self):
            return self.getToken(SolidityParser.SignedIntegerType, 0)

        def UnsignedIntegerType(self):
            return self.getToken(SolidityParser.UnsignedIntegerType, 0)

        def FixedBytes(self):
            return self.getToken(SolidityParser.FixedBytes, 0)

        def Fixed(self):
            return self.getToken(SolidityParser.Fixed, 0)

        def Ufixed(self):
            return self.getToken(SolidityParser.Ufixed, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_elementaryTypeName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementaryTypeName" ):
                return visitor.visitElementaryTypeName(self)
            else:
                return visitor.visitChildren(self)




    def elementaryTypeName(self):

        localctx = SolidityParser.ElementaryTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_elementaryTypeName)
        try:
            self.state = 676
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 665
                self.match(SolidityParser.Address)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 666
                self.match(SolidityParser.Address)
                self.state = 667
                self.match(SolidityParser.Payable)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 668
                self.match(SolidityParser.Bool)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 669
                self.match(SolidityParser.String)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 670
                self.match(SolidityParser.Bytes)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 671
                self.match(SolidityParser.SignedIntegerType)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 672
                self.match(SolidityParser.UnsignedIntegerType)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 673
                self.match(SolidityParser.FixedBytes)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 674
                self.match(SolidityParser.Fixed)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 675
                self.match(SolidityParser.Ufixed)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionTypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.arguments = None # ParameterListContext
            self.returnParameters = None # ParameterListContext

        def Function(self):
            return self.getToken(SolidityParser.Function, 0)

        def LParen(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.LParen)
            else:
                return self.getToken(SolidityParser.LParen, i)

        def RParen(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.RParen)
            else:
                return self.getToken(SolidityParser.RParen, i)

        def visibility(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.VisibilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.VisibilityContext,i)


        def stateMutability(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StateMutabilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StateMutabilityContext,i)


        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def parameterList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterListContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterListContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_functionTypeName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionTypeName" ):
                return visitor.visitFunctionTypeName(self)
            else:
                return visitor.visitChildren(self)




    def functionTypeName(self):

        localctx = SolidityParser.FunctionTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_functionTypeName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 678
            self.match(SolidityParser.Function)
            self.state = 679
            self.match(SolidityParser.LParen)
            self.state = 681
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130:
                self.state = 680
                localctx.arguments = self.parameterList()


            self.state = 683
            self.match(SolidityParser.RParen)
            self.state = 688
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,74,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 686
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [23, 38, 49, 50]:
                        self.state = 684
                        self.visibility()
                        pass
                    elif token in [47, 51, 68]:
                        self.state = 685
                        self.stateMutability()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 690
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,74,self._ctx)

            self.state = 696
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.state = 691
                self.match(SolidityParser.Returns)
                self.state = 692
                self.match(SolidityParser.LParen)
                self.state = 693
                localctx.returnParameters = self.parameterList()
                self.state = 694
                self.match(SolidityParser.RParen)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # TypeNameContext
            self.location = None # DataLocationContext
            self.name = None # IdentifierContext

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def dataLocation(self):
            return self.getTypedRuleContext(SolidityParser.DataLocationContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_variableDeclaration

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = SolidityParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_variableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            localctx.type_ = self.typeName(0)
            self.state = 700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 144119586122368000) != 0):
                self.state = 699
                localctx.location = self.dataLocation()


            self.state = 702
            localctx.name = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataLocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Memory(self):
            return self.getToken(SolidityParser.Memory, 0)

        def Storage(self):
            return self.getToken(SolidityParser.Storage, 0)

        def Calldata(self):
            return self.getToken(SolidityParser.Calldata, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_dataLocation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataLocation" ):
                return visitor.visitDataLocation(self)
            else:
                return visitor.visitChildren(self)




    def dataLocation(self):

        localctx = SolidityParser.DataLocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_dataLocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 704
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 144119586122368000) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SolidityParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class UnaryPrefixOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)

        def Inc(self):
            return self.getToken(SolidityParser.Inc, 0)
        def Dec(self):
            return self.getToken(SolidityParser.Dec, 0)
        def Not(self):
            return self.getToken(SolidityParser.Not, 0)
        def BitNot(self):
            return self.getToken(SolidityParser.BitNot, 0)
        def Delete(self):
            return self.getToken(SolidityParser.Delete, 0)
        def Sub(self):
            return self.getToken(SolidityParser.Sub, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryPrefixOperation" ):
                return visitor.visitUnaryPrefixOperation(self)
            else:
                return visitor.visitChildren(self)


    class PrimaryExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)

        def literal(self):
            return self.getTypedRuleContext(SolidityParser.LiteralContext,0)

        def literalWithSubDenomination(self):
            return self.getTypedRuleContext(SolidityParser.LiteralWithSubDenominationContext,0)

        def elementaryTypeName(self):
            return self.getTypedRuleContext(SolidityParser.ElementaryTypeNameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExpression" ):
                return visitor.visitPrimaryExpression(self)
            else:
                return visitor.visitChildren(self)


    class OrderComparisonContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def LessThan(self):
            return self.getToken(SolidityParser.LessThan, 0)
        def GreaterThan(self):
            return self.getToken(SolidityParser.GreaterThan, 0)
        def LessThanOrEqual(self):
            return self.getToken(SolidityParser.LessThanOrEqual, 0)
        def GreaterThanOrEqual(self):
            return self.getToken(SolidityParser.GreaterThanOrEqual, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderComparison" ):
                return visitor.visitOrderComparison(self)
            else:
                return visitor.visitChildren(self)


    class ConditionalContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def Conditional(self):
            return self.getToken(SolidityParser.Conditional, 0)
        def Colon(self):
            return self.getToken(SolidityParser.Colon, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditional" ):
                return visitor.visitConditional(self)
            else:
                return visitor.visitChildren(self)


    class PayableConversionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Payable(self):
            return self.getToken(SolidityParser.Payable, 0)
        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPayableConversion" ):
                return visitor.visitPayableConversion(self)
            else:
                return visitor.visitChildren(self)


    class AssignmentContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def assignOp(self):
            return self.getTypedRuleContext(SolidityParser.AssignOpContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)


    class UnarySuffixOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)

        def Inc(self):
            return self.getToken(SolidityParser.Inc, 0)
        def Dec(self):
            return self.getToken(SolidityParser.Dec, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnarySuffixOperation" ):
                return visitor.visitUnarySuffixOperation(self)
            else:
                return visitor.visitChildren(self)


    class ShiftOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def Shl(self):
            return self.getToken(SolidityParser.Shl, 0)
        def Sar(self):
            return self.getToken(SolidityParser.Sar, 0)
        def Shr(self):
            return self.getToken(SolidityParser.Shr, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShiftOperation" ):
                return visitor.visitShiftOperation(self)
            else:
                return visitor.visitChildren(self)


    class BitAndOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def BitAnd(self):
            return self.getToken(SolidityParser.BitAnd, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitAndOperation" ):
                return visitor.visitBitAndOperation(self)
            else:
                return visitor.visitChildren(self)


    class FunctionCallContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)

        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class IndexRangeAccessContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.startIndex = None # ExpressionContext
            self.endIndex = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def LBrack(self):
            return self.getToken(SolidityParser.LBrack, 0)
        def Colon(self):
            return self.getToken(SolidityParser.Colon, 0)
        def RBrack(self):
            return self.getToken(SolidityParser.RBrack, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexRangeAccess" ):
                return visitor.visitIndexRangeAccess(self)
            else:
                return visitor.visitChildren(self)


    class IndexAccessContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.index = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def LBrack(self):
            return self.getToken(SolidityParser.LBrack, 0)
        def RBrack(self):
            return self.getToken(SolidityParser.RBrack, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexAccess" ):
                return visitor.visitIndexAccess(self)
            else:
                return visitor.visitChildren(self)


    class AddSubOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def Add(self):
            return self.getToken(SolidityParser.Add, 0)
        def Sub(self):
            return self.getToken(SolidityParser.Sub, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddSubOperation" ):
                return visitor.visitAddSubOperation(self)
            else:
                return visitor.visitChildren(self)


    class BitOrOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def BitOr(self):
            return self.getToken(SolidityParser.BitOr, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitOrOperation" ):
                return visitor.visitBitOrOperation(self)
            else:
                return visitor.visitChildren(self)


    class ExpOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def Exp(self):
            return self.getToken(SolidityParser.Exp, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpOperation" ):
                return visitor.visitExpOperation(self)
            else:
                return visitor.visitChildren(self)


    class AndOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def And(self):
            return self.getToken(SolidityParser.And, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAndOperation" ):
                return visitor.visitAndOperation(self)
            else:
                return visitor.visitChildren(self)


    class InlineArrayContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def inlineArrayExpression(self):
            return self.getTypedRuleContext(SolidityParser.InlineArrayExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInlineArray" ):
                return visitor.visitInlineArray(self)
            else:
                return visitor.visitChildren(self)


    class OrOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def Or(self):
            return self.getToken(SolidityParser.Or, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrOperation" ):
                return visitor.visitOrOperation(self)
            else:
                return visitor.visitChildren(self)


    class MemberAccessContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)

        def Period(self):
            return self.getToken(SolidityParser.Period, 0)
        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)

        def Address(self):
            return self.getToken(SolidityParser.Address, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberAccess" ):
                return visitor.visitMemberAccess(self)
            else:
                return visitor.visitChildren(self)


    class MulDivModOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def Mul(self):
            return self.getToken(SolidityParser.Mul, 0)
        def Div(self):
            return self.getToken(SolidityParser.Div, 0)
        def Mod(self):
            return self.getToken(SolidityParser.Mod, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMulDivModOperation" ):
                return visitor.visitMulDivModOperation(self)
            else:
                return visitor.visitChildren(self)


    class FunctionCallOptionsContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)
        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)
        def namedArgument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.NamedArgumentContext)
            else:
                return self.getTypedRuleContext(SolidityParser.NamedArgumentContext,i)

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCallOptions" ):
                return visitor.visitFunctionCallOptions(self)
            else:
                return visitor.visitChildren(self)


    class NewExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def New(self):
            return self.getToken(SolidityParser.New, 0)
        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNewExpr" ):
                return visitor.visitNewExpr(self)
            else:
                return visitor.visitChildren(self)


    class BitXorOperationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def BitXor(self):
            return self.getToken(SolidityParser.BitXor, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitXorOperation" ):
                return visitor.visitBitXorOperation(self)
            else:
                return visitor.visitChildren(self)


    class TupleContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tupleExpression(self):
            return self.getTypedRuleContext(SolidityParser.TupleExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTuple" ):
                return visitor.visitTuple(self)
            else:
                return visitor.visitChildren(self)


    class EqualityComparisonContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)

        def Equal(self):
            return self.getToken(SolidityParser.Equal, 0)
        def NotEqual(self):
            return self.getToken(SolidityParser.NotEqual, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEqualityComparison" ):
                return visitor.visitEqualityComparison(self)
            else:
                return visitor.visitChildren(self)


    class MetaTypeContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Type(self):
            return self.getToken(SolidityParser.Type, 0)
        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)
        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaType" ):
                return visitor.visitMetaType(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SolidityParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 88
        self.enterRecursionRule(localctx, 88, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 726
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [47]:
                localctx = SolidityParser.PayableConversionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 707
                self.match(SolidityParser.Payable)
                self.state = 708
                self.callArgumentList()
                pass
            elif token in [62]:
                localctx = SolidityParser.MetaTypeContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 709
                self.match(SolidityParser.Type)
                self.state = 710
                self.match(SolidityParser.LParen)
                self.state = 711
                self.typeName(0)
                self.state = 712
                self.match(SolidityParser.RParen)
                pass
            elif token in [16, 105, 116, 117, 118, 119]:
                localctx = SolidityParser.UnaryPrefixOperationContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 714
                _la = self._input.LA(1)
                if not(_la==16 or ((((_la - 105)) & ~0x3f) == 0 and ((1 << (_la - 105)) & 30721) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 715
                self.expression(19)
                pass
            elif token in [44]:
                localctx = SolidityParser.NewExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 716
                self.match(SolidityParser.New)
                self.state = 717
                self.typeName(0)
                pass
            elif token in [71]:
                localctx = SolidityParser.TupleContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 718
                self.tupleExpression()
                pass
            elif token in [73]:
                localctx = SolidityParser.InlineArrayContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 719
                self.inlineArrayExpression()
                pass
            elif token in [3, 7, 9, 21, 25, 26, 27, 29, 31, 55, 56, 58, 60, 63, 66, 122, 123, 124, 125, 126, 128, 130]:
                localctx = SolidityParser.PrimaryExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 724
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 720
                    self.identifier()
                    pass

                elif la_ == 2:
                    self.state = 721
                    self.literal()
                    pass

                elif la_ == 3:
                    self.state = 722
                    self.literalWithSubDenomination()
                    pass

                elif la_ == 4:
                    self.state = 723
                    self.elementaryTypeName()
                    pass


                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 812
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 810
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                    if la_ == 1:
                        localctx = SolidityParser.ExpOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 728
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 729
                        self.match(SolidityParser.Exp)
                        self.state = 730
                        self.expression(17)
                        pass

                    elif la_ == 2:
                        localctx = SolidityParser.MulDivModOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 731
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 732
                        _la = self._input.LA(1)
                        if not(((((_la - 106)) & ~0x3f) == 0 and ((1 << (_la - 106)) & 7) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 733
                        self.expression(17)
                        pass

                    elif la_ == 3:
                        localctx = SolidityParser.AddSubOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 734
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 735
                        _la = self._input.LA(1)
                        if not(_la==104 or _la==105):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 736
                        self.expression(16)
                        pass

                    elif la_ == 4:
                        localctx = SolidityParser.ShiftOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 737
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 738
                        _la = self._input.LA(1)
                        if not(((((_la - 101)) & ~0x3f) == 0 and ((1 << (_la - 101)) & 7) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 739
                        self.expression(15)
                        pass

                    elif la_ == 5:
                        localctx = SolidityParser.BitAndOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 740
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 741
                        self.match(SolidityParser.BitAnd)
                        self.state = 742
                        self.expression(14)
                        pass

                    elif la_ == 6:
                        localctx = SolidityParser.BitXorOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 743
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 744
                        self.match(SolidityParser.BitXor)
                        self.state = 745
                        self.expression(13)
                        pass

                    elif la_ == 7:
                        localctx = SolidityParser.BitOrOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 746
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 747
                        self.match(SolidityParser.BitOr)
                        self.state = 748
                        self.expression(12)
                        pass

                    elif la_ == 8:
                        localctx = SolidityParser.OrderComparisonContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 749
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 750
                        _la = self._input.LA(1)
                        if not(((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 15) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 751
                        self.expression(11)
                        pass

                    elif la_ == 9:
                        localctx = SolidityParser.EqualityComparisonContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 752
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 753
                        _la = self._input.LA(1)
                        if not(_la==110 or _la==111):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 754
                        self.expression(10)
                        pass

                    elif la_ == 10:
                        localctx = SolidityParser.AndOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 755
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 756
                        self.match(SolidityParser.And)
                        self.state = 757
                        self.expression(9)
                        pass

                    elif la_ == 11:
                        localctx = SolidityParser.OrOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 758
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 759
                        self.match(SolidityParser.Or)
                        self.state = 760
                        self.expression(8)
                        pass

                    elif la_ == 12:
                        localctx = SolidityParser.ConditionalContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 761
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 762
                        self.match(SolidityParser.Conditional)
                        self.state = 763
                        self.expression(0)
                        self.state = 764
                        self.match(SolidityParser.Colon)
                        self.state = 765
                        self.expression(6)
                        pass

                    elif la_ == 13:
                        localctx = SolidityParser.AssignmentContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 767
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 768
                        self.assignOp()
                        self.state = 769
                        self.expression(5)
                        pass

                    elif la_ == 14:
                        localctx = SolidityParser.IndexAccessContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 771
                        if not self.precpred(self._ctx, 26):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 26)")
                        self.state = 772
                        self.match(SolidityParser.LBrack)
                        self.state = 774
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                            self.state = 773
                            localctx.index = self.expression(0)


                        self.state = 776
                        self.match(SolidityParser.RBrack)
                        pass

                    elif la_ == 15:
                        localctx = SolidityParser.IndexRangeAccessContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 777
                        if not self.precpred(self._ctx, 25):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 25)")
                        self.state = 778
                        self.match(SolidityParser.LBrack)
                        self.state = 780
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                            self.state = 779
                            localctx.startIndex = self.expression(0)


                        self.state = 782
                        self.match(SolidityParser.Colon)
                        self.state = 784
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                            self.state = 783
                            localctx.endIndex = self.expression(0)


                        self.state = 786
                        self.match(SolidityParser.RBrack)
                        pass

                    elif la_ == 16:
                        localctx = SolidityParser.MemberAccessContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 787
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 788
                        self.match(SolidityParser.Period)
                        self.state = 791
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [21, 29, 31, 55, 130]:
                            self.state = 789
                            self.identifier()
                            pass
                        elif token in [3]:
                            self.state = 790
                            self.match(SolidityParser.Address)
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

                    elif la_ == 17:
                        localctx = SolidityParser.FunctionCallOptionsContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 793
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 794
                        self.match(SolidityParser.LBrace)
                        self.state = 803
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130:
                            self.state = 795
                            self.namedArgument()
                            self.state = 800
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            while _la==95:
                                self.state = 796
                                self.match(SolidityParser.Comma)
                                self.state = 797
                                self.namedArgument()
                                self.state = 802
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)



                        self.state = 805
                        self.match(SolidityParser.RBrace)
                        pass

                    elif la_ == 18:
                        localctx = SolidityParser.FunctionCallContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 806
                        if not self.precpred(self._ctx, 22):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 22)")
                        self.state = 807
                        self.callArgumentList()
                        pass

                    elif la_ == 19:
                        localctx = SolidityParser.UnarySuffixOperationContext(self, SolidityParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 808
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 809
                        _la = self._input.LA(1)
                        if not(_la==118 or _la==119):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass

             
                self.state = 814
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AssignOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Assign(self):
            return self.getToken(SolidityParser.Assign, 0)

        def AssignBitOr(self):
            return self.getToken(SolidityParser.AssignBitOr, 0)

        def AssignBitXor(self):
            return self.getToken(SolidityParser.AssignBitXor, 0)

        def AssignBitAnd(self):
            return self.getToken(SolidityParser.AssignBitAnd, 0)

        def AssignShl(self):
            return self.getToken(SolidityParser.AssignShl, 0)

        def AssignSar(self):
            return self.getToken(SolidityParser.AssignSar, 0)

        def AssignShr(self):
            return self.getToken(SolidityParser.AssignShr, 0)

        def AssignAdd(self):
            return self.getToken(SolidityParser.AssignAdd, 0)

        def AssignSub(self):
            return self.getToken(SolidityParser.AssignSub, 0)

        def AssignMul(self):
            return self.getToken(SolidityParser.AssignMul, 0)

        def AssignDiv(self):
            return self.getToken(SolidityParser.AssignDiv, 0)

        def AssignMod(self):
            return self.getToken(SolidityParser.AssignMod, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_assignOp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignOp" ):
                return visitor.visitAssignOp(self)
            else:
                return visitor.visitChildren(self)




    def assignOp(self):

        localctx = SolidityParser.AssignOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_assignOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 815
            _la = self._input.LA(1)
            if not(((((_la - 83)) & ~0x3f) == 0 and ((1 << (_la - 83)) & 4095) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TupleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_tupleExpression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTupleExpression" ):
                return visitor.visitTupleExpression(self)
            else:
                return visitor.visitChildren(self)




    def tupleExpression(self):

        localctx = SolidityParser.TupleExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_tupleExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 817
            self.match(SolidityParser.LParen)

            self.state = 819
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                self.state = 818
                self.expression(0)


            self.state = 827
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==95:
                self.state = 821
                self.match(SolidityParser.Comma)
                self.state = 823
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                    self.state = 822
                    self.expression(0)


                self.state = 829
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 830
            self.match(SolidityParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InlineArrayExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBrack(self):
            return self.getToken(SolidityParser.LBrack, 0)

        def RBrack(self):
            return self.getToken(SolidityParser.RBrack, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_inlineArrayExpression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInlineArrayExpression" ):
                return visitor.visitInlineArrayExpression(self)
            else:
                return visitor.visitChildren(self)




    def inlineArrayExpression(self):

        localctx = SolidityParser.InlineArrayExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_inlineArrayExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 832
            self.match(SolidityParser.LBrack)

            self.state = 833
            self.expression(0)
            self.state = 838
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==95:
                self.state = 834
                self.match(SolidityParser.Comma)
                self.state = 835
                self.expression(0)
                self.state = 840
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 841
            self.match(SolidityParser.RBrack)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(SolidityParser.Identifier, 0)

        def From(self):
            return self.getToken(SolidityParser.From, 0)

        def Error(self):
            return self.getToken(SolidityParser.Error, 0)

        def Revert(self):
            return self.getToken(SolidityParser.Revert, 0)

        def Global(self):
            return self.getToken(SolidityParser.Global, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_identifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = SolidityParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 843
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringLiteral(self):
            return self.getTypedRuleContext(SolidityParser.StringLiteralContext,0)


        def numberLiteral(self):
            return self.getTypedRuleContext(SolidityParser.NumberLiteralContext,0)


        def booleanLiteral(self):
            return self.getTypedRuleContext(SolidityParser.BooleanLiteralContext,0)


        def hexStringLiteral(self):
            return self.getTypedRuleContext(SolidityParser.HexStringLiteralContext,0)


        def unicodeStringLiteral(self):
            return self.getTypedRuleContext(SolidityParser.UnicodeStringLiteralContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = SolidityParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_literal)
        try:
            self.state = 850
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [122, 123]:
                self.enterOuterAlt(localctx, 1)
                self.state = 845
                self.stringLiteral()
                pass
            elif token in [126, 128]:
                self.enterOuterAlt(localctx, 2)
                self.state = 846
                self.numberLiteral()
                pass
            elif token in [25, 60]:
                self.enterOuterAlt(localctx, 3)
                self.state = 847
                self.booleanLiteral()
                pass
            elif token in [125]:
                self.enterOuterAlt(localctx, 4)
                self.state = 848
                self.hexStringLiteral()
                pass
            elif token in [124]:
                self.enterOuterAlt(localctx, 5)
                self.state = 849
                self.unicodeStringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralWithSubDenominationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberLiteral(self):
            return self.getTypedRuleContext(SolidityParser.NumberLiteralContext,0)


        def SubDenomination(self):
            return self.getToken(SolidityParser.SubDenomination, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_literalWithSubDenomination

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralWithSubDenomination" ):
                return visitor.visitLiteralWithSubDenomination(self)
            else:
                return visitor.visitChildren(self)




    def literalWithSubDenomination(self):

        localctx = SolidityParser.LiteralWithSubDenominationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_literalWithSubDenomination)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 852
            self.numberLiteral()
            self.state = 853
            self.match(SolidityParser.SubDenomination)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def True_(self):
            return self.getToken(SolidityParser.True_, 0)

        def False_(self):
            return self.getToken(SolidityParser.False_, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_booleanLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanLiteral" ):
                return visitor.visitBooleanLiteral(self)
            else:
                return visitor.visitChildren(self)




    def booleanLiteral(self):

        localctx = SolidityParser.BooleanLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_booleanLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 855
            _la = self._input.LA(1)
            if not(_la==25 or _la==60):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NonEmptyStringLiteral(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.NonEmptyStringLiteral)
            else:
                return self.getToken(SolidityParser.NonEmptyStringLiteral, i)

        def EmptyStringLiteral(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.EmptyStringLiteral)
            else:
                return self.getToken(SolidityParser.EmptyStringLiteral, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_stringLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def stringLiteral(self):

        localctx = SolidityParser.StringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_stringLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 858 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 857
                    _la = self._input.LA(1)
                    if not(_la==122 or _la==123):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 860 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HexStringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HexString(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.HexString)
            else:
                return self.getToken(SolidityParser.HexString, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_hexStringLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHexStringLiteral" ):
                return visitor.visitHexStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def hexStringLiteral(self):

        localctx = SolidityParser.HexStringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_hexStringLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 863 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 862
                    self.match(SolidityParser.HexString)

                else:
                    raise NoViableAltException(self)
                self.state = 865 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,93,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnicodeStringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UnicodeStringLiteral(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.UnicodeStringLiteral)
            else:
                return self.getToken(SolidityParser.UnicodeStringLiteral, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_unicodeStringLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnicodeStringLiteral" ):
                return visitor.visitUnicodeStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def unicodeStringLiteral(self):

        localctx = SolidityParser.UnicodeStringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_unicodeStringLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 868 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 867
                    self.match(SolidityParser.UnicodeStringLiteral)

                else:
                    raise NoViableAltException(self)
                self.state = 870 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DecimalNumber(self):
            return self.getToken(SolidityParser.DecimalNumber, 0)

        def HexNumber(self):
            return self.getToken(SolidityParser.HexNumber, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_numberLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteral" ):
                return visitor.visitNumberLiteral(self)
            else:
                return visitor.visitChildren(self)




    def numberLiteral(self):

        localctx = SolidityParser.NumberLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_numberLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 872
            _la = self._input.LA(1)
            if not(_la==126 or _la==128):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StatementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StatementContext,i)


        def uncheckedBlock(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.UncheckedBlockContext)
            else:
                return self.getTypedRuleContext(SolidityParser.UncheckedBlockContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_block

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = SolidityParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 874
            self.match(SolidityParser.LBrace)
            self.state = 879
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -4705115643001345927) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & 1581819034729447467) != 0):
                self.state = 877
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 6, 7, 8, 9, 14, 16, 17, 19, 21, 25, 26, 27, 28, 29, 30, 31, 33, 41, 44, 47, 53, 55, 56, 58, 60, 61, 62, 63, 66, 70, 71, 73, 75, 105, 116, 117, 118, 119, 122, 123, 124, 125, 126, 128, 130]:
                    self.state = 875
                    self.statement()
                    pass
                elif token in [64]:
                    self.state = 876
                    self.uncheckedBlock()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 881
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 882
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UncheckedBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Unchecked(self):
            return self.getToken(SolidityParser.Unchecked, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_uncheckedBlock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUncheckedBlock" ):
                return visitor.visitUncheckedBlock(self)
            else:
                return visitor.visitChildren(self)




    def uncheckedBlock(self):

        localctx = SolidityParser.UncheckedBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_uncheckedBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 884
            self.match(SolidityParser.Unchecked)
            self.state = 885
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def simpleStatement(self):
            return self.getTypedRuleContext(SolidityParser.SimpleStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(SolidityParser.IfStatementContext,0)


        def forStatement(self):
            return self.getTypedRuleContext(SolidityParser.ForStatementContext,0)


        def whileStatement(self):
            return self.getTypedRuleContext(SolidityParser.WhileStatementContext,0)


        def doWhileStatement(self):
            return self.getTypedRuleContext(SolidityParser.DoWhileStatementContext,0)


        def continueStatement(self):
            return self.getTypedRuleContext(SolidityParser.ContinueStatementContext,0)


        def breakStatement(self):
            return self.getTypedRuleContext(SolidityParser.BreakStatementContext,0)


        def tryStatement(self):
            return self.getTypedRuleContext(SolidityParser.TryStatementContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(SolidityParser.ReturnStatementContext,0)


        def emitStatement(self):
            return self.getTypedRuleContext(SolidityParser.EmitStatementContext,0)


        def revertStatement(self):
            return self.getTypedRuleContext(SolidityParser.RevertStatementContext,0)


        def assemblyStatement(self):
            return self.getTypedRuleContext(SolidityParser.AssemblyStatementContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_statement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = SolidityParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_statement)
        try:
            self.state = 900
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 887
                self.block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 888
                self.simpleStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 889
                self.ifStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 890
                self.forStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 891
                self.whileStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 892
                self.doWhileStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 893
                self.continueStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 894
                self.breakStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 895
                self.tryStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 896
                self.returnStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 897
                self.emitStatement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 898
                self.revertStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 899
                self.assemblyStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclarationStatement(self):
            return self.getTypedRuleContext(SolidityParser.VariableDeclarationStatementContext,0)


        def expressionStatement(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionStatementContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_simpleStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleStatement" ):
                return visitor.visitSimpleStatement(self)
            else:
                return visitor.visitChildren(self)




    def simpleStatement(self):

        localctx = SolidityParser.SimpleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_simpleStatement)
        try:
            self.state = 904
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 902
                self.variableDeclarationStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 903
                self.expressionStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def If(self):
            return self.getToken(SolidityParser.If, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StatementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StatementContext,i)


        def Else(self):
            return self.getToken(SolidityParser.Else, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_ifStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = SolidityParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 906
            self.match(SolidityParser.If)
            self.state = 907
            self.match(SolidityParser.LParen)
            self.state = 908
            self.expression(0)
            self.state = 909
            self.match(SolidityParser.RParen)
            self.state = 910
            self.statement()
            self.state = 913
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 911
                self.match(SolidityParser.Else)
                self.state = 912
                self.statement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def For(self):
            return self.getToken(SolidityParser.For, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def statement(self):
            return self.getTypedRuleContext(SolidityParser.StatementContext,0)


        def simpleStatement(self):
            return self.getTypedRuleContext(SolidityParser.SimpleStatementContext,0)


        def Semicolon(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Semicolon)
            else:
                return self.getToken(SolidityParser.Semicolon, i)

        def expressionStatement(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionStatementContext,0)


        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_forStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForStatement" ):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)




    def forStatement(self):

        localctx = SolidityParser.ForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_forStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 915
            self.match(SolidityParser.For)
            self.state = 916
            self.match(SolidityParser.LParen)
            self.state = 919
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 7, 9, 16, 21, 25, 26, 27, 29, 30, 31, 41, 44, 47, 55, 56, 58, 60, 62, 63, 66, 71, 73, 105, 116, 117, 118, 119, 122, 123, 124, 125, 126, 128, 130]:
                self.state = 917
                self.simpleStatement()
                pass
            elif token in [78]:
                self.state = 918
                self.match(SolidityParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 923
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 7, 9, 16, 21, 25, 26, 27, 29, 31, 44, 47, 55, 56, 58, 60, 62, 63, 66, 71, 73, 105, 116, 117, 118, 119, 122, 123, 124, 125, 126, 128, 130]:
                self.state = 921
                self.expressionStatement()
                pass
            elif token in [78]:
                self.state = 922
                self.match(SolidityParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 926
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                self.state = 925
                self.expression(0)


            self.state = 928
            self.match(SolidityParser.RParen)
            self.state = 929
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def While(self):
            return self.getToken(SolidityParser.While, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def statement(self):
            return self.getTypedRuleContext(SolidityParser.StatementContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_whileStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileStatement" ):
                return visitor.visitWhileStatement(self)
            else:
                return visitor.visitChildren(self)




    def whileStatement(self):

        localctx = SolidityParser.WhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_whileStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 931
            self.match(SolidityParser.While)
            self.state = 932
            self.match(SolidityParser.LParen)
            self.state = 933
            self.expression(0)
            self.state = 934
            self.match(SolidityParser.RParen)
            self.state = 935
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoWhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Do(self):
            return self.getToken(SolidityParser.Do, 0)

        def statement(self):
            return self.getTypedRuleContext(SolidityParser.StatementContext,0)


        def While(self):
            return self.getToken(SolidityParser.While, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_doWhileStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoWhileStatement" ):
                return visitor.visitDoWhileStatement(self)
            else:
                return visitor.visitChildren(self)




    def doWhileStatement(self):

        localctx = SolidityParser.DoWhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_doWhileStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 937
            self.match(SolidityParser.Do)
            self.state = 938
            self.statement()
            self.state = 939
            self.match(SolidityParser.While)
            self.state = 940
            self.match(SolidityParser.LParen)
            self.state = 941
            self.expression(0)
            self.state = 942
            self.match(SolidityParser.RParen)
            self.state = 943
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinueStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Continue(self):
            return self.getToken(SolidityParser.Continue, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_continueStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContinueStatement" ):
                return visitor.visitContinueStatement(self)
            else:
                return visitor.visitChildren(self)




    def continueStatement(self):

        localctx = SolidityParser.ContinueStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_continueStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 945
            self.match(SolidityParser.Continue)
            self.state = 946
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(SolidityParser.Break, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_breakStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreakStatement" ):
                return visitor.visitBreakStatement(self)
            else:
                return visitor.visitChildren(self)




    def breakStatement(self):

        localctx = SolidityParser.BreakStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_breakStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 948
            self.match(SolidityParser.Break)
            self.state = 949
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TryStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.returnParameters = None # ParameterListContext

        def Try(self):
            return self.getToken(SolidityParser.Try, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def catchClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.CatchClauseContext)
            else:
                return self.getTypedRuleContext(SolidityParser.CatchClauseContext,i)


        def parameterList(self):
            return self.getTypedRuleContext(SolidityParser.ParameterListContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_tryStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTryStatement" ):
                return visitor.visitTryStatement(self)
            else:
                return visitor.visitChildren(self)




    def tryStatement(self):

        localctx = SolidityParser.TryStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_tryStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 951
            self.match(SolidityParser.Try)
            self.state = 952
            self.expression(0)
            self.state = 958
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 953
                self.match(SolidityParser.Returns)
                self.state = 954
                self.match(SolidityParser.LParen)
                self.state = 955
                localctx.returnParameters = self.parameterList()
                self.state = 956
                self.match(SolidityParser.RParen)


            self.state = 960
            self.block()
            self.state = 962 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 961
                self.catchClause()
                self.state = 964 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==11):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CatchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.arguments = None # ParameterListContext

        def Catch(self):
            return self.getToken(SolidityParser.Catch, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext,0)


        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext,0)


        def parameterList(self):
            return self.getTypedRuleContext(SolidityParser.ParameterListContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_catchClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCatchClause" ):
                return visitor.visitCatchClause(self)
            else:
                return visitor.visitChildren(self)




    def catchClause(self):

        localctx = SolidityParser.CatchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_catchClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 966
            self.match(SolidityParser.Catch)
            self.state = 974
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==71 or _la==130:
                self.state = 968
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130:
                    self.state = 967
                    self.identifier()


                self.state = 970
                self.match(SolidityParser.LParen)

                self.state = 971
                localctx.arguments = self.parameterList()
                self.state = 972
                self.match(SolidityParser.RParen)


            self.state = 976
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Return(self):
            return self.getToken(SolidityParser.Return, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_returnStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = SolidityParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_returnStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 978
            self.match(SolidityParser.Return)
            self.state = 980
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -7300315204393099183) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 790909517364723717) != 0):
                self.state = 979
                self.expression(0)


            self.state = 982
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmitStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Emit(self):
            return self.getToken(SolidityParser.Emit, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext,0)


        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_emitStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmitStatement" ):
                return visitor.visitEmitStatement(self)
            else:
                return visitor.visitChildren(self)




    def emitStatement(self):

        localctx = SolidityParser.EmitStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_emitStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 984
            self.match(SolidityParser.Emit)
            self.state = 985
            self.expression(0)
            self.state = 986
            self.callArgumentList()
            self.state = 987
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RevertStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Revert(self):
            return self.getToken(SolidityParser.Revert, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext,0)


        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_revertStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRevertStatement" ):
                return visitor.visitRevertStatement(self)
            else:
                return visitor.visitChildren(self)




    def revertStatement(self):

        localctx = SolidityParser.RevertStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_revertStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 989
            self.match(SolidityParser.Revert)
            self.state = 990
            self.expression(0)
            self.state = 991
            self.callArgumentList()
            self.state = 992
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssemblyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Assembly(self):
            return self.getToken(SolidityParser.Assembly, 0)

        def AssemblyLBrace(self):
            return self.getToken(SolidityParser.AssemblyLBrace, 0)

        def YulRBrace(self):
            return self.getToken(SolidityParser.YulRBrace, 0)

        def AssemblyDialect(self):
            return self.getToken(SolidityParser.AssemblyDialect, 0)

        def assemblyFlags(self):
            return self.getTypedRuleContext(SolidityParser.AssemblyFlagsContext,0)


        def yulStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulStatementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulStatementContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_assemblyStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssemblyStatement" ):
                return visitor.visitAssemblyStatement(self)
            else:
                return visitor.visitChildren(self)




    def assemblyStatement(self):

        localctx = SolidityParser.AssemblyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_assemblyStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 994
            self.match(SolidityParser.Assembly)
            self.state = 996
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==134:
                self.state = 995
                self.match(SolidityParser.AssemblyDialect)


            self.state = 999
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==137:
                self.state = 998
                self.assemblyFlags()


            self.state = 1001
            self.match(SolidityParser.AssemblyLBrace)
            self.state = 1005
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 143)) & ~0x3f) == 0 and ((1 << (_la - 143)) & 4220901) != 0):
                self.state = 1002
                self.yulStatement()
                self.state = 1007
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1008
            self.match(SolidityParser.YulRBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssemblyFlagsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AssemblyBlockLParen(self):
            return self.getToken(SolidityParser.AssemblyBlockLParen, 0)

        def AssemblyFlagString(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.AssemblyFlagString)
            else:
                return self.getToken(SolidityParser.AssemblyFlagString, i)

        def AssemblyBlockRParen(self):
            return self.getToken(SolidityParser.AssemblyBlockRParen, 0)

        def AssemblyBlockComma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.AssemblyBlockComma)
            else:
                return self.getToken(SolidityParser.AssemblyBlockComma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_assemblyFlags

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssemblyFlags" ):
                return visitor.visitAssemblyFlags(self)
            else:
                return visitor.visitChildren(self)




    def assemblyFlags(self):

        localctx = SolidityParser.AssemblyFlagsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_assemblyFlags)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1010
            self.match(SolidityParser.AssemblyBlockLParen)
            self.state = 1011
            self.match(SolidityParser.AssemblyFlagString)
            self.state = 1016
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==139:
                self.state = 1012
                self.match(SolidityParser.AssemblyBlockComma)
                self.state = 1013
                self.match(SolidityParser.AssemblyFlagString)
                self.state = 1018
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1019
            self.match(SolidityParser.AssemblyBlockRParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._variableDeclaration = None # VariableDeclarationContext
            self.variableDeclarations = list() # of VariableDeclarationContexts

        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.VariableDeclarationContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_variableDeclarationList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclarationList" ):
                return visitor.visitVariableDeclarationList(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclarationList(self):

        localctx = SolidityParser.VariableDeclarationListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_variableDeclarationList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1021
            localctx._variableDeclaration = self.variableDeclaration()
            localctx.variableDeclarations.append(localctx._variableDeclaration)
            self.state = 1026
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==95:
                self.state = 1022
                self.match(SolidityParser.Comma)
                self.state = 1023
                localctx._variableDeclaration = self.variableDeclaration()
                localctx.variableDeclarations.append(localctx._variableDeclaration)
                self.state = 1028
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationTupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._variableDeclaration = None # VariableDeclarationContext
            self.variableDeclarations = list() # of VariableDeclarationContexts

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.VariableDeclarationContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_variableDeclarationTuple

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclarationTuple" ):
                return visitor.visitVariableDeclarationTuple(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclarationTuple(self):

        localctx = SolidityParser.VariableDeclarationTupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_variableDeclarationTuple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1029
            self.match(SolidityParser.LParen)

            self.state = 1033
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==95:
                self.state = 1030
                self.match(SolidityParser.Comma)
                self.state = 1035
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1036
            localctx._variableDeclaration = self.variableDeclaration()
            localctx.variableDeclarations.append(localctx._variableDeclaration)
            self.state = 1044
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==95:
                self.state = 1038
                self.match(SolidityParser.Comma)
                self.state = 1040
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & -8020910660973756335) != 0) or _la==130:
                    self.state = 1039
                    localctx._variableDeclaration = self.variableDeclaration()
                    localctx.variableDeclarations.append(localctx._variableDeclaration)


                self.state = 1046
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1047
            self.match(SolidityParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def variableDeclaration(self):
            return self.getTypedRuleContext(SolidityParser.VariableDeclarationContext,0)


        def variableDeclarationTuple(self):
            return self.getTypedRuleContext(SolidityParser.VariableDeclarationTupleContext,0)


        def Assign(self):
            return self.getToken(SolidityParser.Assign, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_variableDeclarationStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclarationStatement" ):
                return visitor.visitVariableDeclarationStatement(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclarationStatement(self):

        localctx = SolidityParser.VariableDeclarationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_variableDeclarationStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1058
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 7, 9, 21, 26, 27, 29, 30, 31, 41, 55, 56, 58, 63, 66, 130]:
                self.state = 1049
                self.variableDeclaration()
                self.state = 1052
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==83:
                    self.state = 1050
                    self.match(SolidityParser.Assign)
                    self.state = 1051
                    self.expression(0)


                pass
            elif token in [71]:
                self.state = 1054
                self.variableDeclarationTuple()
                self.state = 1055
                self.match(SolidityParser.Assign)
                self.state = 1056
                self.expression(0)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1060
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext,0)


        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_expressionStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionStatement" ):
                return visitor.visitExpressionStatement(self)
            else:
                return visitor.visitChildren(self)




    def expressionStatement(self):

        localctx = SolidityParser.ExpressionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_expressionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1062
            self.expression(0)
            self.state = 1063
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MappingTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.key = None # MappingKeyTypeContext
            self.name = None # IdentifierContext
            self.value = None # TypeNameContext

        def Mapping(self):
            return self.getToken(SolidityParser.Mapping, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def DoubleArrow(self):
            return self.getToken(SolidityParser.DoubleArrow, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def mappingKeyType(self):
            return self.getTypedRuleContext(SolidityParser.MappingKeyTypeContext,0)


        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext,0)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_mappingType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMappingType" ):
                return visitor.visitMappingType(self)
            else:
                return visitor.visitChildren(self)




    def mappingType(self):

        localctx = SolidityParser.MappingTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_mappingType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1065
            self.match(SolidityParser.Mapping)
            self.state = 1066
            self.match(SolidityParser.LParen)
            self.state = 1067
            localctx.key = self.mappingKeyType()
            self.state = 1069
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130:
                self.state = 1068
                localctx.name = self.identifier()


            self.state = 1071
            self.match(SolidityParser.DoubleArrow)
            self.state = 1072
            localctx.value = self.typeName(0)
            self.state = 1074
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la==130:
                self.state = 1073
                localctx.name = self.identifier()


            self.state = 1076
            self.match(SolidityParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MappingKeyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementaryTypeName(self):
            return self.getTypedRuleContext(SolidityParser.ElementaryTypeNameContext,0)


        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_mappingKeyType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMappingKeyType" ):
                return visitor.visitMappingKeyType(self)
            else:
                return visitor.visitChildren(self)




    def mappingKeyType(self):

        localctx = SolidityParser.MappingKeyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_mappingKeyType)
        try:
            self.state = 1080
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 7, 9, 26, 27, 56, 58, 63, 66]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1078
                self.elementaryTypeName()
                pass
            elif token in [21, 29, 31, 55, 130]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1079
                self.identifierPath()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext,0)


        def yulVariableDeclaration(self):
            return self.getTypedRuleContext(SolidityParser.YulVariableDeclarationContext,0)


        def yulAssignment(self):
            return self.getTypedRuleContext(SolidityParser.YulAssignmentContext,0)


        def yulFunctionCall(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionCallContext,0)


        def yulIfStatement(self):
            return self.getTypedRuleContext(SolidityParser.YulIfStatementContext,0)


        def yulForStatement(self):
            return self.getTypedRuleContext(SolidityParser.YulForStatementContext,0)


        def yulSwitchStatement(self):
            return self.getTypedRuleContext(SolidityParser.YulSwitchStatementContext,0)


        def YulLeave(self):
            return self.getToken(SolidityParser.YulLeave, 0)

        def YulBreak(self):
            return self.getToken(SolidityParser.YulBreak, 0)

        def YulContinue(self):
            return self.getToken(SolidityParser.YulContinue, 0)

        def yulFunctionDefinition(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionDefinitionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_yulStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulStatement" ):
                return visitor.visitYulStatement(self)
            else:
                return visitor.visitChildren(self)




    def yulStatement(self):

        localctx = SolidityParser.YulStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_yulStatement)
        try:
            self.state = 1093
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1082
                self.yulBlock()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1083
                self.yulVariableDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1084
                self.yulAssignment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1085
                self.yulFunctionCall()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1086
                self.yulIfStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1087
                self.yulForStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1088
                self.yulSwitchStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1089
                self.match(SolidityParser.YulLeave)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1090
                self.match(SolidityParser.YulBreak)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1091
                self.match(SolidityParser.YulContinue)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1092
                self.yulFunctionDefinition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulLBrace(self):
            return self.getToken(SolidityParser.YulLBrace, 0)

        def YulRBrace(self):
            return self.getToken(SolidityParser.YulRBrace, 0)

        def yulStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulStatementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulStatementContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_yulBlock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulBlock" ):
                return visitor.visitYulBlock(self)
            else:
                return visitor.visitChildren(self)




    def yulBlock(self):

        localctx = SolidityParser.YulBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_yulBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1095
            self.match(SolidityParser.YulLBrace)
            self.state = 1099
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 143)) & ~0x3f) == 0 and ((1 << (_la - 143)) & 4220901) != 0):
                self.state = 1096
                self.yulStatement()
                self.state = 1101
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1102
            self.match(SolidityParser.YulRBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._YulIdentifier = None # Token
            self.variables = list() # of Tokens

        def YulLet(self):
            return self.getToken(SolidityParser.YulLet, 0)

        def YulIdentifier(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulIdentifier)
            else:
                return self.getToken(SolidityParser.YulIdentifier, i)

        def YulAssign(self):
            return self.getToken(SolidityParser.YulAssign, 0)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext,0)


        def YulComma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulComma)
            else:
                return self.getToken(SolidityParser.YulComma, i)

        def yulFunctionCall(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionCallContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_yulVariableDeclaration

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulVariableDeclaration" ):
                return visitor.visitYulVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def yulVariableDeclaration(self):

        localctx = SolidityParser.YulVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_yulVariableDeclaration)
        self._la = 0 # Token type
        try:
            self.state = 1123
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1104
                self.match(SolidityParser.YulLet)
                self.state = 1105
                localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                localctx.variables.append(localctx._YulIdentifier)
                self.state = 1108
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==161:
                    self.state = 1106
                    self.match(SolidityParser.YulAssign)
                    self.state = 1107
                    self.yulExpression()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1110
                self.match(SolidityParser.YulLet)
                self.state = 1111
                localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                localctx.variables.append(localctx._YulIdentifier)
                self.state = 1116
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==163:
                    self.state = 1112
                    self.match(SolidityParser.YulComma)
                    self.state = 1113
                    localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                    localctx.variables.append(localctx._YulIdentifier)
                    self.state = 1118
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1121
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==161:
                    self.state = 1119
                    self.match(SolidityParser.YulAssign)
                    self.state = 1120
                    self.yulFunctionCall()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def yulPath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulPathContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulPathContext,i)


        def YulAssign(self):
            return self.getToken(SolidityParser.YulAssign, 0)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext,0)


        def yulFunctionCall(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionCallContext,0)


        def YulComma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulComma)
            else:
                return self.getToken(SolidityParser.YulComma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulAssignment

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulAssignment" ):
                return visitor.visitYulAssignment(self)
            else:
                return visitor.visitChildren(self)




    def yulAssignment(self):

        localctx = SolidityParser.YulAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_yulAssignment)
        self._la = 0 # Token type
        try:
            self.state = 1139
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1125
                self.yulPath()
                self.state = 1126
                self.match(SolidityParser.YulAssign)
                self.state = 1127
                self.yulExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1129
                self.yulPath()
                self.state = 1132 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1130
                    self.match(SolidityParser.YulComma)
                    self.state = 1131
                    self.yulPath()
                    self.state = 1134 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==163):
                        break

                self.state = 1136
                self.match(SolidityParser.YulAssign)
                self.state = 1137
                self.yulFunctionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cond = None # YulExpressionContext
            self.body = None # YulBlockContext

        def YulIf(self):
            return self.getToken(SolidityParser.YulIf, 0)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext,0)


        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_yulIfStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulIfStatement" ):
                return visitor.visitYulIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def yulIfStatement(self):

        localctx = SolidityParser.YulIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_yulIfStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1141
            self.match(SolidityParser.YulIf)
            self.state = 1142
            localctx.cond = self.yulExpression()
            self.state = 1143
            localctx.body = self.yulBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.init = None # YulBlockContext
            self.cond = None # YulExpressionContext
            self.post = None # YulBlockContext
            self.body = None # YulBlockContext

        def YulFor(self):
            return self.getToken(SolidityParser.YulFor, 0)

        def yulBlock(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulBlockContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulBlockContext,i)


        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_yulForStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulForStatement" ):
                return visitor.visitYulForStatement(self)
            else:
                return visitor.visitChildren(self)




    def yulForStatement(self):

        localctx = SolidityParser.YulForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_yulForStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1145
            self.match(SolidityParser.YulFor)
            self.state = 1146
            localctx.init = self.yulBlock()
            self.state = 1147
            localctx.cond = self.yulExpression()
            self.state = 1148
            localctx.post = self.yulBlock()
            self.state = 1149
            localctx.body = self.yulBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulSwitchCaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulCase(self):
            return self.getToken(SolidityParser.YulCase, 0)

        def yulLiteral(self):
            return self.getTypedRuleContext(SolidityParser.YulLiteralContext,0)


        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_yulSwitchCase

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulSwitchCase" ):
                return visitor.visitYulSwitchCase(self)
            else:
                return visitor.visitChildren(self)




    def yulSwitchCase(self):

        localctx = SolidityParser.YulSwitchCaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_yulSwitchCase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1151
            self.match(SolidityParser.YulCase)
            self.state = 1152
            self.yulLiteral()
            self.state = 1153
            self.yulBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulSwitchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulSwitch(self):
            return self.getToken(SolidityParser.YulSwitch, 0)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext,0)


        def YulDefault(self):
            return self.getToken(SolidityParser.YulDefault, 0)

        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext,0)


        def yulSwitchCase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulSwitchCaseContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulSwitchCaseContext,i)


        def getRuleIndex(self):
            return SolidityParser.RULE_yulSwitchStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulSwitchStatement" ):
                return visitor.visitYulSwitchStatement(self)
            else:
                return visitor.visitChildren(self)




    def yulSwitchStatement(self):

        localctx = SolidityParser.YulSwitchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_yulSwitchStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1155
            self.match(SolidityParser.YulSwitch)
            self.state = 1156
            self.yulExpression()
            self.state = 1168
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [144]:
                self.state = 1158 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1157
                    self.yulSwitchCase()
                    self.state = 1160 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==144):
                        break

                self.state = 1164
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==146:
                    self.state = 1162
                    self.match(SolidityParser.YulDefault)
                    self.state = 1163
                    self.yulBlock()


                pass
            elif token in [146]:
                self.state = 1166
                self.match(SolidityParser.YulDefault)
                self.state = 1167
                self.yulBlock()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulFunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._YulIdentifier = None # Token
            self.arguments = list() # of Tokens
            self.returnParameters = list() # of Tokens
            self.body = None # YulBlockContext

        def YulFunction(self):
            return self.getToken(SolidityParser.YulFunction, 0)

        def YulIdentifier(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulIdentifier)
            else:
                return self.getToken(SolidityParser.YulIdentifier, i)

        def YulLParen(self):
            return self.getToken(SolidityParser.YulLParen, 0)

        def YulRParen(self):
            return self.getToken(SolidityParser.YulRParen, 0)

        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext,0)


        def YulArrow(self):
            return self.getToken(SolidityParser.YulArrow, 0)

        def YulComma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulComma)
            else:
                return self.getToken(SolidityParser.YulComma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulFunctionDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulFunctionDefinition" ):
                return visitor.visitYulFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def yulFunctionDefinition(self):

        localctx = SolidityParser.YulFunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_yulFunctionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1170
            self.match(SolidityParser.YulFunction)
            self.state = 1171
            self.match(SolidityParser.YulIdentifier)
            self.state = 1172
            self.match(SolidityParser.YulLParen)
            self.state = 1181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==165:
                self.state = 1173
                localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                localctx.arguments.append(localctx._YulIdentifier)
                self.state = 1178
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==163:
                    self.state = 1174
                    self.match(SolidityParser.YulComma)
                    self.state = 1175
                    localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                    localctx.arguments.append(localctx._YulIdentifier)
                    self.state = 1180
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1183
            self.match(SolidityParser.YulRParen)
            self.state = 1193
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==164:
                self.state = 1184
                self.match(SolidityParser.YulArrow)
                self.state = 1185
                localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                localctx.returnParameters.append(localctx._YulIdentifier)
                self.state = 1190
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==163:
                    self.state = 1186
                    self.match(SolidityParser.YulComma)
                    self.state = 1187
                    localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                    localctx.returnParameters.append(localctx._YulIdentifier)
                    self.state = 1192
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1195
            localctx.body = self.yulBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulPathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulIdentifier(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulIdentifier)
            else:
                return self.getToken(SolidityParser.YulIdentifier, i)

        def YulPeriod(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulPeriod)
            else:
                return self.getToken(SolidityParser.YulPeriod, i)

        def YulEVMBuiltin(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulEVMBuiltin)
            else:
                return self.getToken(SolidityParser.YulEVMBuiltin, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulPath

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulPath" ):
                return visitor.visitYulPath(self)
            else:
                return visitor.visitChildren(self)




    def yulPath(self):

        localctx = SolidityParser.YulPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_yulPath)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1197
            self.match(SolidityParser.YulIdentifier)
            self.state = 1202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==162:
                self.state = 1198
                self.match(SolidityParser.YulPeriod)
                self.state = 1199
                _la = self._input.LA(1)
                if not(_la==156 or _la==165):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1204
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulLParen(self):
            return self.getToken(SolidityParser.YulLParen, 0)

        def YulRParen(self):
            return self.getToken(SolidityParser.YulRParen, 0)

        def YulIdentifier(self):
            return self.getToken(SolidityParser.YulIdentifier, 0)

        def YulEVMBuiltin(self):
            return self.getToken(SolidityParser.YulEVMBuiltin, 0)

        def yulExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulExpressionContext,i)


        def YulComma(self, i:int=None):
            if i is None:
                return self.getTokens(SolidityParser.YulComma)
            else:
                return self.getToken(SolidityParser.YulComma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulFunctionCall

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulFunctionCall" ):
                return visitor.visitYulFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def yulFunctionCall(self):

        localctx = SolidityParser.YulFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_yulFunctionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1205
            _la = self._input.LA(1)
            if not(_la==156 or _la==165):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1206
            self.match(SolidityParser.YulLParen)
            self.state = 1215
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 147)) & ~0x3f) == 0 and ((1 << (_la - 147)) & 8127105) != 0):
                self.state = 1207
                self.yulExpression()
                self.state = 1212
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==163:
                    self.state = 1208
                    self.match(SolidityParser.YulComma)
                    self.state = 1209
                    self.yulExpression()
                    self.state = 1214
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1217
            self.match(SolidityParser.YulRParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulBooleanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulTrue(self):
            return self.getToken(SolidityParser.YulTrue, 0)

        def YulFalse(self):
            return self.getToken(SolidityParser.YulFalse, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulBoolean

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulBoolean" ):
                return visitor.visitYulBoolean(self)
            else:
                return visitor.visitChildren(self)




    def yulBoolean(self):

        localctx = SolidityParser.YulBooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_yulBoolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1219
            _la = self._input.LA(1)
            if not(_la==147 or _la==154):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulDecimalNumber(self):
            return self.getToken(SolidityParser.YulDecimalNumber, 0)

        def YulStringLiteral(self):
            return self.getToken(SolidityParser.YulStringLiteral, 0)

        def YulHexNumber(self):
            return self.getToken(SolidityParser.YulHexNumber, 0)

        def yulBoolean(self):
            return self.getTypedRuleContext(SolidityParser.YulBooleanContext,0)


        def YulHexStringLiteral(self):
            return self.getToken(SolidityParser.YulHexStringLiteral, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulLiteral" ):
                return visitor.visitYulLiteral(self)
            else:
                return visitor.visitChildren(self)




    def yulLiteral(self):

        localctx = SolidityParser.YulLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_yulLiteral)
        try:
            self.state = 1226
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [167]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1221
                self.match(SolidityParser.YulDecimalNumber)
                pass
            elif token in [168]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1222
                self.match(SolidityParser.YulStringLiteral)
                pass
            elif token in [166]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1223
                self.match(SolidityParser.YulHexNumber)
                pass
            elif token in [147, 154]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1224
                self.yulBoolean()
                pass
            elif token in [169]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1225
                self.match(SolidityParser.YulHexStringLiteral)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YulExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def yulPath(self):
            return self.getTypedRuleContext(SolidityParser.YulPathContext,0)


        def yulFunctionCall(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionCallContext,0)


        def yulLiteral(self):
            return self.getTypedRuleContext(SolidityParser.YulLiteralContext,0)


        def getRuleIndex(self):
            return SolidityParser.RULE_yulExpression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYulExpression" ):
                return visitor.visitYulExpression(self)
            else:
                return visitor.visitChildren(self)




    def yulExpression(self):

        localctx = SolidityParser.YulExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_yulExpression)
        try:
            self.state = 1231
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,140,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1228
                self.yulPath()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1229
                self.yulFunctionCall()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1230
                self.yulLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[39] = self.typeName_sempred
        self._predicates[44] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def typeName_sempred(self, localctx:TypeNameContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 26)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 25)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 24)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 23)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 22)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 18)
         




